<!DOCTYPE HTML>
<html><head><title>09July2013_165204</title><link href="http://netdna.bootstrapcdn.com/twitter-bootstrap/2.3.2/css/bootstrap-combined.min.css" rel="stylesheet"><script src="https://ajax.googleapis.com/ajax/libs/jquery/1.9.0/jquery.min.js"></script><script src="http://netdna.bootstrapcdn.com/twitter-bootstrap/2.3.2/js/bootstrap.min.js"></script></head><body><div class="container"><div class="row"><div class="span12"><h3>Baysig test run #09July2013_165204</h3><table class="table table-condensed"><tr><th>package</th><th>git commit hash</th><th>modified</th></tr><tr><td>baysig-core</td><td>2174c5f56681f72279d2b444f06464b56e4ad6e6
</td><td></td></tr><tr><td>bugsess</td><td>066ef6f74b3bb466ed8af0e9fd099dbba7df5236
</td><td></td></tr><tr><td>baysig-exec</td><td>efae33b845a8388b1aa678c2eaaa2a5275cd1e0e
</td><td>Yes</td></tr></table><table class="table table-condensed"><tr><td><h4>UnfoldEstim</h4></td><td>401 ms</td><td><a onclick="$('#UnfoldEstim').toggle();" class="btn" href="javascript:void(0);">Show/hide code</a></td></tr><tr id="UnfoldEstim" style="display: none;"><td colspan="3"><pre>module UnfoldEstim where

import Distributions.bug

samples = 1000

model = prob
  v ~ gamma 1 1
  x0 ~ normal 0 0.1
  y0 ~ normal 0 0.1
  ys ~ unfold 100 (x0,y0) $ \(x,y) -&gt; prob
         z ~ normal x v
         w ~ normal y v
	 return (w,z)
  return $ map fst ys

model1 &lt;* updateS model $ return { v =&gt; 0.1; x0=&gt;0.2; y0 =&gt; -0.5 }

fakeData &lt;* sample model1

--fakeData *&gt; console

pars &lt;* estimateStan model fakeData

assert_unfold_initx = Mostly $ with pars $ x0 &gt; 0
assert_unfold_inity = Mostly $ with pars $ y0 &lt; 0

pars *&gt; console

--z0 = with pars $ head ys 

--z0 *&gt; console </pre></td></tr><tr style="background-color: rgb(255, 220, 220);"><td>assert_unfold_initx</td><td>fail</td><td>33.5%</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_unfold_inity</td><td>pass</td><td>50.7%</td></tr><tr><td><h4>DistributionTest</h4></td><td>1122 ms</td><td><a onclick="$('#DistributionTest').toggle();" class="btn" href="javascript:void(0);">Show/hide code</a></td></tr><tr id="DistributionTest" style="display: none;"><td colspan="3"><pre>{-
TEST_COMPILER_ONLY
-}

module DistributionTest where

import Distributions.bug

assert_normal_range = Always $ fmap (\x-&gt;x&lt;10) $ normal 0 1

assert_normal_larger = Mostly $ prob x ~ normal 0 1
                                     y ~ normal 1 1 
                                     return $ x &lt; y
                              
eunorm = expect (normal 0 1)

assert_expect = eunorm &gt; (-1) &amp;&amp; eunorm &lt; 1

dec_prob = prob
   x ~ normal 10 1
   y ~ normal 10 1
   return (x,y)

dec_util v (x,y) = 1000 - abs ((v!0) - x) - abs ((v!1) - y)

dec_ini : Vector Real
dec_ini = fillV 2 (const 5.1)

dec = decide 0.001 dec_ini dec_prob dec_util

rp &lt;* sample dec_prob

assert_sample = between 5 15 (fst rp) &amp;&amp; between 5 15 (snd rp)

assert_decide = between 8 12 (dec!0) &amp;&amp; between 8 12 (dec!1)

dec *&gt; console

expect (normal 10 5) *&gt; console</pre></td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_normal_range</td><td>pass</td><td>True,True,True,True,True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_normal_larger</td><td>pass</td><td>73.6%</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_expect</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_sample</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_decide</td><td>pass</td><td>True</td></tr><tr><td><h4>HestonEstim2</h4></td><td>161965 ms</td><td><a onclick="$('#HestonEstim2').toggle();" class="btn" href="javascript:void(0);">Show/hide code</a></td></tr><tr id="HestonEstim2" style="display: none;"><td colspan="3"><pre>module HestonCook where

import Distributions.bug
tmax = 10.0
dt = 0.01

samples= 2000

heston = prob
   k     ~ gamma 1 1
   th    ~ gamma 1 0.1
   eta   ~ gamma 1 0.1
   mu    ~ normal 0 0.1
   w1    ~ wiener
   w2    ~ wiener
   v_0   ~ gamma 1 0.1
   s_0   ~ uniform 0.0 2.0
   d v t = k * (th - v t) + eta * sqrt (v t) * d w1 t
   d s t = mu * s t + sqrt (v t) * s t * d w2 t
   return {s=&gt;s; v=&gt;v}

heston1  &lt;* updateS heston (return {  k=&gt;1.0;
                                      th=&gt;0.02;
                                      eta=&gt;0.1;
                                      mu=&gt;0.05;
                                      v_0=&gt;0.02;
                                      s_0=&gt;1.0})



fakedata &lt;* sample heston1

xy_sdata = let (ObservedSignal dt1 t0 vpts) = observeSig $ fakedata#s
	      pts = vecToList vpts
              ts = map (\i-&gt; unround i * dt1) $ fromTo 0 (length pts-1)
          in zip ts pts

fake_xy = packXYL xy_sdata

pars &lt;* estimateStan heston {s=&gt;fake_xy}

--vsam &lt;* sample $ with pars v

--vsam 1.0 *&gt; console

assert_k_pos = Mostly (with pars $ k &gt; 0.0)

assert_v_pos = Mostly (with pars $ v 5.0 &gt; 0.0)

hestonForward &lt;* fastForward heston pars {s=&gt;fake_xy}

future &lt;* sample hestonForward

--future 5.0 *&gt; console

assert_fast_forward = (future#s) 0.1 &gt; 0

plt = psigPlot $ with hestonForward s 
</pre></td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_k_pos</td><td>pass</td><td>100%</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_v_pos</td><td>pass</td><td>100%</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_fast_forward</td><td>pass</td><td>True</td></tr><tr><td><h4>PoissonRegress</h4></td><td>215 ms</td><td><a onclick="$('#PoissonRegress').toggle();" class="btn" href="javascript:void(0);">Show/hide code</a></td></tr><tr id="PoissonRegress" style="display: none;"><td colspan="3"><pre>module RegressEstim where

import Distributions.bug

samples = 10000

regress = prob
   slope   ~  normal 0.0 10.0
   repeat 50  $ prob w ~ uniform 0.0 1.0
                     y ~ poisson (slope*w) 
                     return $ { foo=&gt;w;bar=&gt;y }

regress1 &lt;* updateS regress $ return { slope=&gt;10 }

fakedata &lt;* sample regress1

pars &lt;* estimateStan regress fakedata

--pars *&gt; console

ns &lt;* sample (repeat 2000 $ poisson 3)

assert_mean_poisson = between 2.8 3.2 $ (unround (sum ns) / 2000) 

assert_mean_pos = Mostly (with pars $ slope &gt; 2.0)

</pre></td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_mean_poisson</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_mean_pos</td><td>pass</td><td>100%</td></tr><tr><td><h4>LogisticEstim1</h4></td><td>395 ms</td><td><a onclick="$('#LogisticEstim1').toggle();" class="btn" href="javascript:void(0);">Show/hide code</a></td></tr><tr id="LogisticEstim1" style="display: none;"><td colspan="3"><pre>module RegressCook where

import Distributions.bug

logistic = prob
   offset  ~  normal 0 2
   slope   ~  uniform (-10) 10.0
   repeat 20  $ prob   w ~ uniform 0.0 1.0
                       y ~ bernoulli01(invlogit(offset+slope*w))
                       return (w,y) 
  
logistic1 &lt;* updateS logistic $ return { offset =&gt; (-2.0);
					 slope =&gt; 4.0}

fakeData &lt;* sample logistic1

logitPars &lt;* estimateStan logistic fakeData

assert_mean_pos = Mostly (with logitPars $ slope &gt; 0.5)
            

</pre></td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_mean_pos</td><td>pass</td><td>98.5%</td></tr><tr><td><h4>NestedRegression1</h4></td><td>6148 ms</td><td><a onclick="$('#NestedRegression1').toggle();" class="btn" href="javascript:void(0);">Show/hide code</a></td></tr><tr id="NestedRegression1" style="display: none;"><td colspan="3"><pre>module RegressEstim where

import Distributions.bug

samples = 10000

nestReg = prob
   offsetmean  ~  normal 0.0 10.0
   offsetvar   ~  gamma 1 1
   slopemean   ~  normal 0 10.0
   slopevar    ~  gamma 1 1
   sigma       ~  gamma 1 1
   groups ~ repeat 20 $ prob
      slope  ~ normal slopemean slopevar
      offset ~ normal offsetmean offsetvar
      indivs ~ repeat 20 $ prob
          w ~ uniform 0.0 1.0
          y ~ normal (offset+slope*w) sigma
          return $ {foo=&gt;w;bar=&gt;y}
      return indivs
   return groups

nestReg1 &lt;* updateS nestReg $ return { offsetmean=&gt; (-1);
	    	    	      	       offsetvar=&gt; 0.1;
	    	    	      	       slopemean=&gt;1;
				       slopevar=&gt;0.1;
				       sigma=&gt;0.1 }

fakedata &lt;* sample nestReg1

pars &lt;* estimateStan nestReg fakedata


assert_mean_pos = Mostly (with pars $ slopemean &gt; 0.5)
assert_offset_neg = Mostly (with pars $ offsetmean &lt; 0.5)

assert_nested_slope = Mostly (with pars $ (head groups)#slope &gt; 0.5)
assert_nested_offset = Mostly (with pars $ (head groups)#offset &lt; 0.0)
</pre></td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_mean_pos</td><td>pass</td><td>100%</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_offset_neg</td><td>pass</td><td>100%</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_nested_slope</td><td>pass</td><td>100%</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_nested_offset</td><td>pass</td><td>100%</td></tr><tr><td><h4>RecFail</h4></td><td>0 ms</td><td><a onclick="$('#RecFail').toggle();" class="btn" href="javascript:void(0);">Show/hide code</a></td></tr><tr id="RecFail" style="display: none;"><td colspan="3"><pre>module Records where

import Prelude.bug

--f3 : Int -&gt; { a:Int; b:Bool; c:String }
f3 x = { a=&gt;x; b=&gt;False }

f4 : Int -&gt; { a:Int; b:Bool; c:String }
f4 x = case x &gt; 0 of
     True -&gt; { a=&gt;x; b=&gt;False }
     False -&gt; { a=&gt;x; c=&gt;&quot;neg&quot; } </pre></td></tr><tr style="background-color: rgb(220, 255, 220);"><td>RecFail_must_fail</td><td>pass</td><td>Cannot unify the following types in f4:
{a:Int, b:Bool, c:String} and {a:Int, b:Bool}
Bool and String
{a:Int, b:Bool, c:String} and {a:?x_2, c:String}
</td></tr><tr><td><h4>PreludeTests</h4></td><td>111 ms</td><td><a onclick="$('#PreludeTests').toggle();" class="btn" href="javascript:void(0);">Show/hide code</a></td></tr><tr id="PreludeTests" style="display: none;"><td colspan="3"><pre>module PreludeTest where

import Prelude.bug

assert_fac3 = fac 3 == 6

assert_pairs0 = 2 == fst (2,3)
assert_pairs1 = 3 == snd (2,3)

assert_case = case 1 of
        0 -&gt; False
        1 -&gt; True

assert_case1 = case 1 of
        0 -&gt; False
        _ -&gt; True

assert_case2 = case 1 of
        0 -&gt; False
        x -&gt; True

assert_case3 = not $ case 0 of
        0 -&gt; False
        x -&gt; True


assert_case_mb = case Just 5 of
	          Just x -&gt; x == 5
                  Nothing -&gt; False

assert_2p2eq4 = 2+2 == 4

nothing_to_see = let &lt;x,y,z&gt; = fillV 3 (\i-&gt; unround i)
	       	 in ()


--the mere definition of these makes the test suite loop forever. not good. 
--commenting out pred-prey code fixes this. 
--wierd interaction between mutually recursive functions and ODEs
--FIXME

--myeven 0 = True
--myeven n =  myodd (n-1)

--myodd 0 = False
--myodd n = myeven (n-1)

infixl 5 &lt;&gt;

x &lt;&gt; y = x + y + 5

assert_custom_infix = (1&lt;&gt;2)==8



--implicit parameters


fimpl foo? bar = foo+(bar:Int)

impl_res = let foo = 2
           in fimpl 5

assert_implicit_params = impl_res == 7
	 

pair_num_list = (3, [5])

assert_pair_num_list = fst pair_num_list == 3

--some overloading stuff

myOverLoaded : Num a -&gt; Num a -&gt; Num a
myOverLoaded x y = x + y + 1

assert_overload1 = between 10 11 $ myOverLoaded 5 4.5

assert_eq1 = (1:Int) == (1:Int)
assert_eq2 = &quot;foo&quot; == &quot;foo&quot;
assert_eq3 = True == True

eqnum = id $ 2+2

--ASSERT_TYPE eqnum (Num a)


pr3 = (fac $ 4, &quot;hello&quot;)
pr4 = (&quot;bar&quot;, fac $ 2)

assert_pair_dollar1 = fst pr3 &lt; 30
assert_pair_dollar2 = snd pr4 &lt; 30


</pre></td></tr><tr style="background-color: rgb(220, 255, 220);"><td>asserted_type_of_eqnum</td><td>pass</td><td>Num a</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_fac3</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_pairs0</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_pairs1</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_case</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_case1</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_case2</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_case3</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_case_mb</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_2p2eq4</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_custom_infix</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_implicit_params</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_pair_num_list</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_overload1</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_eq1</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_eq2</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_eq3</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_pair_dollar1</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_pair_dollar2</td><td>pass</td><td>True</td></tr><tr><td><h4>RecursiveTests</h4></td><td>123 ms</td><td><a onclick="$('#RecursiveTests').toggle();" class="btn" href="javascript:void(0);">Show/hide code</a></td></tr><tr id="RecursiveTests" style="display: none;"><td colspan="3"><pre>module RecursiveTests where

import Prelude.bug


myeven 0 = True
myeven n =  myodd (n-1)

myodd 0 = False
myodd n = myeven (n-1)

myeven1 0 = True
myeven1 n =  myodd1 (n-1)

myodd1 0 = False
myodd1 n = myeven1 (n-1)


assert_even_4 = myeven 4
assert_even1_4 = myeven1 4
assert_odd_5 = myodd 5
assert_odd1_5 = myodd 5
assert_noteven_5 = not $ myeven 5

</pre></td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_even_4</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_even1_4</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_odd_5</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_odd1_5</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_noteven_5</td><td>pass</td><td>True</td></tr><tr><td><h4>RegressLarge</h4></td><td>2297 ms</td><td><a onclick="$('#RegressLarge').toggle();" class="btn" href="javascript:void(0);">Show/hide code</a></td></tr><tr id="RegressLarge" style="display: none;"><td colspan="3"><pre>module RegressEstim where

import Distributions.bug

samples = 1000

regress = prob
   offset  ~  normal 0 1.0
   sigma   ~  gamma 1 1
   slope   ~  normal 0.0 1.0
   repeat 5000 $ prob w ~ uniform 0.0 1.0
                      y ~ normal (offset+slope*w) sigma
                      return $ { foo=&gt;w;bar=&gt;y }

regress1 &lt;* updateS regress $ return { offset=&gt; (-0.5);slope=&gt;1;sigma=&gt;0.1 }

fakedata &lt;* sample regress1

pars &lt;* estimateStan regress fakedata

assert_mean_pos = Mostly (with pars $ slope &gt; 0.5)

</pre></td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_mean_pos</td><td>pass</td><td>100%</td></tr><tr><td><h4>ParserTest</h4></td><td>123 ms</td><td><a onclick="$('#ParserTest').toggle();" class="btn" href="javascript:void(0);">Show/hide code</a></td></tr><tr id="ParserTest" style="display: none;"><td colspan="3"><pre>module ParserTest where

import Prelude.bug


xs = [1.1,2.2,3.3,4.4,5.5]

res = runP xs $ bindP headP $ \x0 -&gt; bindP (takeP 2) $ \l1-&gt; bindP (takeP 3) $ \l2-&gt; returnP {foo=&gt;l1;bar=&gt;l2;baz=&gt;x0}

assert_lst_parse_take = length (res#foo) == 2

assert_lst_parse_num = between 1.0 1.2 (res#baz)</pre></td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_lst_parse_take</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_lst_parse_num</td><td>pass</td><td>True</td></tr><tr><td><h4>HestonEstim</h4></td><td>67780 ms</td><td><a onclick="$('#HestonEstim').toggle();" class="btn" href="javascript:void(0);">Show/hide code</a></td></tr><tr id="HestonEstim" style="display: none;"><td colspan="3"><pre>module HestonCook where

import Distributions.bug
tmax = 5.0
dt = 0.01

samples= 2000

heston = prob
   k     ~ gamma 1 1
   th    ~ gamma 1 0.1
   eta   ~ gamma 1 0.1
   mu    ~ normal 0 0.1
   w1    ~ wiener
   w2    ~ wiener
   v_0   ~ gamma 1 0.1
   s_0   ~ uniform 0.0 2.0
   d v t = k * (th - v t) + eta * sqrt (v t) * d w1 t
   d s t = mu * s t + sqrt (v t) * s t * d w2 t
   return s

heston1  &lt;* updateS heston (return {  k=&gt;1.0;
                                      th=&gt;0.02;
                                      eta=&gt;0.1;
                                      mu=&gt;0.05;
                                      v_0=&gt;0.02;
                                      s_0=&gt;1.0})



fakedata &lt;* sample heston1

pars &lt;* estimateStan heston fakedata

pars *&gt; console

vsam &lt;* sample $ with pars $ v

val &lt;* sample $ with pars $ v (tmax-1)

val *&gt; console

assert_k_pos = Mostly (with pars $ k &gt; 0.0)

assert_v_pos = Mostly (with pars $ v 5.0 &gt; 0.0)

hestonForward &lt;* fastForward heston pars fakedata

future &lt;* sample hestonForward

--future 5.0 *&gt; console

assert_fast_forward = future 0.1 &gt; 0

</pre></td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_k_pos</td><td>pass</td><td>100%</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_v_pos</td><td>pass</td><td>100%</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_fast_forward</td><td>pass</td><td>True</td></tr><tr><td><h4>ODETests</h4></td><td>112 ms</td><td><a onclick="$('#ODETests').toggle();" class="btn" href="javascript:void(0);">Show/hide code</a></td></tr><tr id="ODETests" style="display: none;"><td colspan="3"><pre>module PreludeTest where

import Prelude.bug

--ODEs

dt = 0.005
tmax = 1.1

mysig_0 = 1.0

D mysig t = sin (mysig t)

assert_ode = between 1.9 2.0 $ mysig 1.0

rvalpha   = 0.1
rvbeta    = 0.01
rvgamma   = 0.05
rvdelta   = 0.001
prey_0      = 50.0 
pred_0      = 15
D prey t    =     prey t    * (rvalpha  - rvbeta   * pred t) 
D pred t    =  -  pred t    * (rvgamma  - rvdelta  * prey t)

assert_prey = between 47 48 $ prey 1.0
assert_pred = between 14.5 15.5 $ pred 1.0

s3 = let zz_0 = 1.0
         D zz = \t -&gt; sin t
     in zz

s4 = let v_0 = -0.07
         w_0 = 0.0
         D v = \t -&gt; 0.01 * v t -  w t
         D w = \t -&gt; 0.3 *  w t - v t
     in v 

assert_let_odes = s4 1.0 &lt; 0 
</pre></td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_ode</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_prey</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_pred</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_let_odes</td><td>pass</td><td>True</td></tr><tr><td><h4>SDETests</h4></td><td>3107 ms</td><td><a onclick="$('#SDETests').toggle();" class="btn" href="javascript:void(0);">Show/hide code</a></td></tr><tr id="SDETests" style="display: none;"><td colspan="3"><pre>module PreludeTest where

import Distributions.bug

dt = 0.005
tmax = 2.1


w2 = prob
       w ~ wiener
       return (w 2.0)

assert_wiener_var2 = SamplerDensity (w2) (normalLogPdf 0 2)

w3 = prob
       w ~ wiener
       s_0 = 1
       d s t = 0 + d w t
       return (s 2.0)

assert_sde_dist = SamplerDensity (w3) (normalLogPdf 1 2)

w4 = prob
       w ~ wiener
       s_0 = 0
       d s t = - s t + d w t
       return (s 2.0)


assert_ou_dist = SamplerDensity (w4) (normalLogPdf 0 0.5) -- ?

w5 = prob
       w ~ wiener
       s_0 = 1
       d s t = s t + d w t
       return (s 2.0)


</pre></td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_wiener_var2</td><td>pass</td><td>-4.192302835678002,-4.007328787460748,-3.975178195725422,-3.368856980419247,-3.3235176213050837</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_sde_dist</td><td>pass</td><td>-2.684974973541394,-2.5930519975534367,-2.48549427395059,-2.401114075272114,-2.050591521669087</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_ou_dist</td><td>pass</td><td>-2.2691746453129626,-1.8425379340693295,-1.7917897422352425,-1.6346085073040153,-1.6258807078702304</td></tr><tr><td><h4>Records</h4></td><td>118 ms</td><td><a onclick="$('#Records').toggle();" class="btn" href="javascript:void(0);">Show/hide code</a></td></tr><tr id="Records" style="display: none;"><td colspan="3"><pre>module PreludeTest where

import Prelude.bug

-- records

--ASSERT_TYPE rec1 {foo: Int; bar: String}

rec1 = {foo=&gt;(5:Int); bar=&gt;&quot;foo&quot;}

assert_rec_access1 = rec1#foo &gt; 4



rec2 = {baz=&gt;True}
--doesnt work for now: rec2 = rec1;baz=&gt;True or rec2 = baz=&gt;True;rec1

assert_rec_access2= rec2#baz

rec1foo = let {..} = rec1
	  in foo

assert_rec1_wild = between 4 6 rec1foo


--ASSERT_TYPE rec3 {foo: Real; bar: String; zoo: Real-&gt; Real}

rec3 = {foo=&gt;5.5; bar=&gt;&quot;foo&quot;; zoo=&gt; \x-&gt;1.1+x }

assert_rec_access3 = rec3#foo &gt; 4

assert_rec_access4 = rec3 # &quot;foo&quot; &gt; 4

rec4 = [{boo=&gt;2.3}]

prec2 = return rec2

prec3 = with prec2 $ map (\{..} -&gt;if baz then boo else 0.0 ) rec4



slope_threshold = 0.1
a = { slope =&gt; 1.2 }

b = { slope =&gt; 1.5; slope_threshold =&gt; 0.5 }

f : {slope: Real} -&gt; Bool
f = \{..} -&gt; slope &gt; slope_threshold

tst1 = f a
--tst2 = f b
tst3 = let slope_threshold = 1.0 in f a
--tst4 = let slope_threshold = 1.0 in f b

lrec0 = [{male=&gt;True; age=&gt;35}, {male=&gt;False; age=&gt;36}]

lrec1 = lrec0 &lt;|&gt; male &lt;#&gt; age

assert_inwithwhen0 = length lrec1 == 1
assert_inwithwhen1 = head lrec1 == 35 

growth = return {genotype =&gt; &quot;A&quot;;photoperiod =&gt; &quot;veryshort&quot;;growth =&gt; 2}

--growth &lt;#&gt; genotype *&gt; console


--ian&#39;s wildcard problem

ian = &quot;I am grumpy&quot;

ian_list_recs = [{ian=&gt;2.0;happy=&gt;False}]

ian_res = with ian_list_recs ian

ian_res *&gt; console</pre></td></tr><tr style="background-color: rgb(220, 255, 220);"><td>asserted_type_of_rec1</td><td>pass</td><td>{foo:Int, bar:String}</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>asserted_type_of_rec3</td><td>pass</td><td>{foo:Real, bar:String, zoo:Real -&gt; Real}</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_rec_access1</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_rec_access2</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_rec1_wild</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_rec_access3</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_rec_access4</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_inwithwhen0</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_inwithwhen1</td><td>pass</td><td>True</td></tr><tr><td><h4>List</h4></td><td>385 ms</td><td><a onclick="$('#List').toggle();" class="btn" href="javascript:void(0);">Show/hide code</a></td></tr><tr id="List" style="display: none;"><td colspan="3"><pre>module PreludeTest where

import Prelude.bug

lst = Cons 5.3 $ Cons 2.1 Nil

--ASSERT_TYPE lst (List Real)

f x = 2 * x + 1

assert_fhead = between 10 12 $ f $ head lst

assert_bool1 = (True &amp;&amp; False) || (True || False)

assert_bool2 = not $ (True &amp;&amp; False) || (True &amp;&amp; False)

assert_cmp = if ((f $ head lst) &gt; 10) then True else False

assert_negative = -5 &lt; 0

assert_length1 = length lst == 2

lst_lit = [6.2, 4.5, 8.9]

map_lst_lit = map (\x-&gt; x+1) lst_lit

assert_length2 = length lst_lit == 3

assert_length3 = length (take 2 lst_lit) == 2

assert_length5 = length (drop 2 lst_lit) == 1

assert_length4 = length lst_lit == 3

assert_list_filter = length (filter (\x-&gt; x&gt;7) lst_lit) == 1
assert_list_filter0 = length (filter (\x-&gt; x&gt;7) []) == 0

assert_litlist1 = between 6 7 $ ix 0 lst_lit
assert_litlist2 = between 8 9 $ ix 2 lst_lit
assert_litlist3 = between 8 9 $ ix 1 $ drop 1 lst_lit

assert_litlist1_map = between 7 8 $ ix 0 map_lst_lit
assert_litlist2_map = between 9 10 $ ix 2 map_lst_lit

assert_litlist1_fmap = between 7 8 $ ix 0 $ fmap (\x-&gt; x+1) lst_lit
assert_litlist2_fmap = between 9 10 $ ix 2 $ fmap (\x-&gt; x+1) lst_lit
assert_fmap_nil = length (fmap f Nil) == 0

llpat = let [x,y] = lst
        in x

assert_list_lit_pattern = between 5 6 llpat

rng = fromTo 1 10

scanned = scanl (\x-&gt; \y-&gt; x+y) 0 rng

assert_scanl_length = length scanned == 11

assert_scanl_val = between 44 46 $ ix 9 scanned 

longList =  fromTo 0 1000000

sumFromTo lo hi = foldl (\x -&gt; \y -&gt; x+y) 0 $ fromTo lo hi

--sumFromTo 0 100 *&gt; console

assert_shortfromto = sumFromTo 0 100 == 5050

big_number = sumFromTo 0 100000

--big_number *&gt; console

assert_thin_length = length (thin 1 (linspace 0 1 30)) == 15
assert_thin_length1 = length (thin 10 (linspace 0 1 100)) == 10

--length (thinTo 10 (linspace 0 1 50)) *&gt; console
--thinTo 10 (linspace 0 1 50) *&gt; console

lstmbs = [Just (1:Int), Nothing]

assert_lstmbs 
  = case lstmbs of 
      Cons (Just x) _ -&gt; x == 1
      _ -&gt; False

lst5 = fromTo 0 5
lst6 = fromTo 0 6

assert_zip_len = length lst5 == length (zip lst5 lst6)

elem x [] = False
elem x (Cons y ys) = if x == y then True else elem x ys


nub xs = nub&#39; xs []
nub&#39; [] _ = []
nub&#39; (Cons x xs) ls = if (elem x ls) then nub&#39; xs ls else (Cons x (nub&#39; xs (Cons x ls)))</pre></td></tr><tr style="background-color: rgb(220, 255, 220);"><td>asserted_type_of_lst</td><td>pass</td><td>List Real</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_fhead</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_bool1</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_bool2</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_cmp</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_negative</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_length1</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_length2</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_length3</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_length5</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_length4</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_list_filter</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_list_filter0</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_litlist1</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_litlist2</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_litlist3</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_litlist1_map</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_litlist2_map</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_litlist1_fmap</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_litlist2_fmap</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_fmap_nil</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_list_lit_pattern</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_scanl_length</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_scanl_val</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_shortfromto</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_thin_length</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_thin_length1</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_lstmbs</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_zip_len</td><td>pass</td><td>True</td></tr><tr><td><h4>LogisticEstim</h4></td><td>370 ms</td><td><a onclick="$('#LogisticEstim').toggle();" class="btn" href="javascript:void(0);">Show/hide code</a></td></tr><tr id="LogisticEstim" style="display: none;"><td colspan="3"><pre>module RegressCook where

import Distributions.bug

logistic = prob
   offset  ~  normal 0 2
   slope   ~  uniform (-10) 10.0
   repeat 20  $ prob   w ~ uniform 0.0 1.0
                       y ~ bernoulli(invlogit(offset+slope*w))
                       return (w,y) 
  
logistic1 &lt;* updateS logistic $ return { offset =&gt; (-2.0);
					 slope =&gt; 4.0}

fakeData &lt;* sample logistic1

logitPars &lt;* estimateStan logistic fakeData

assert_mean_pos = Mostly (with logitPars $ slope &gt; 0.5)
            

</pre></td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_mean_pos</td><td>pass</td><td>99%</td></tr><tr><td><h4>WishList</h4></td><td>113 ms</td><td><a onclick="$('#WishList').toggle();" class="btn" href="javascript:void(0);">Show/hide code</a></td></tr><tr id="WishList" style="display: none;"><td colspan="3"><pre>module WishList where

import Prelude.bug

pair_num_list = (3,[5])

assert_pair_num_list = fst pair_num_list == 3
</pre></td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_pair_num_list</td><td>pass</td><td>True</td></tr><tr><td><h4>Prob</h4></td><td>140 ms</td><td><a onclick="$('#Prob').toggle();" class="btn" href="javascript:void(0);">Show/hide code</a></td></tr><tr id="Prob" style="display: none;"><td colspan="3"><pre>module ProbTest where

import Prelude.bug

--simple distributions

fixdist = prob
  x ~ return (4:Int)
  y ~ return 5
  return (x + y)

fixdist1 = prob
  x ~ return (4:Int)
  y ~ return 5
  w = x + y
  return (w + y)

nestedDo = prob
  x ~ prob 
    z ~ unit
    return z
  return $ x+1

mySamples = Samples [ 10.0,11.2,13.6, 12.1,11.5,10.8]
--mySamples *&gt; console

--ASSERT_TYPE d2 (Prob Real)

d2 = fmap (\w -&gt; w+1) mySamples
--d2 *&gt; console

d3 = filter (\v -&gt; v&gt;12) mySamples

d4 = prob 
       dt = 0.001
       tmax = 1
       s_0 = 1
       D s t = sin(t)
       return $ s

d5 = fmap (\sig-&gt; sig 0.5) d4

--ASSERT_TYPE d5 (Prob Real)
    

assert_filter_samples = Always $ fmap (\w-&gt;w&gt;12) d3
assert_filter_sampler = Always $ fmap (\x-&gt;x&gt;0.5) $ filter (\x-&gt;x&gt;0.5) unit

--TODO: parse error on: 
--fmap (\w -&gt; w+1) mySamples *&gt; console

assert_fmap_samples = Always $ fmap (\w-&gt;w&gt;6) $ mySamples

fixdistSam &lt;* sample $ fmap (\w-&gt;w&gt;6) fixdist
fixdist1Sam &lt;* sample $ fmap (\w-&gt;w&gt;10) fixdist1
nestedDoSam &lt;* sample $ fmap (\w-&gt;w&gt;1.0) nestedDo

assert_fixdist = fixdistSam
assert_fixdist1 = fixdist1Sam
assert_nestedDo = nestedDoSam



wdist = return {xr =&gt; 2 }

wdistSam &lt;* sample $ with wdist (between 1 3 xr) 
assert_with = wdistSam

repeatDist = repeat 10 $ unit

repeated &lt;* sample repeatDist

assert_repeat_map 
   = let v = ix 5 (map (\x-&gt; 1.0+x) repeated) 
     in v &gt; 1.0 &amp;&amp; v &lt; 2.0

assert_repeat_length = length repeated == 10

-- repeatDist -&gt; repeated : loops forever or a long time FIXME. should go in type_must_fail.
assert_repeat_different = Mostly $ fmap (\xs-&gt; abs(ix 5 xs - ix 6 xs) &gt; 0.05) repeatDist

-- fixP testing

fixUnit &lt;* sample $ fixP 100 unit

--fixThin &lt;* sample $ fixP 10 fixUnit


assert_fix_samples 
  = case countSamples fixUnit of
      Nothing -&gt; False
      Just n -&gt; n == 100

{-
assert_thin_samples 
  = case countSamples fixThin of
      Nothing -&gt; False
      Just n -&gt; n &lt; 50
-}</pre></td></tr><tr style="background-color: rgb(220, 255, 220);"><td>asserted_type_of_d2</td><td>pass</td><td>Prob Real</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>asserted_type_of_d5</td><td>pass</td><td>Prob Real</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_fixdist</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_fixdist1</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_nestedDo</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_with</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_filter_samples</td><td>pass</td><td>True,True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_filter_sampler</td><td>pass</td><td>True,True,True,True,True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_fmap_samples</td><td>pass</td><td>True,True,True,True,True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_repeat_map</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_repeat_length</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_repeat_different</td><td>pass</td><td>93.4%</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_fix_samples</td><td>pass</td><td>True</td></tr><tr><td><h4>DensityTests</h4></td><td>403 ms</td><td><a onclick="$('#DensityTests').toggle();" class="btn" href="javascript:void(0);">Show/hide code</a></td></tr><tr id="DensityTests" style="display: none;"><td colspan="3"><pre>module DensityTests where

import Distributions.bug

assert_normal_sampler_pdf1 = SamplerDensity (normal 0 1) (normalLogPdf 0 1)
assert_normal_sampler_pdf3 = SamplerDensity (normal 1 10) (normalLogPdf 1 10)
assert_normal_sampler_pdf5 = SamplerDensity (normal 10 1) (normalLogPdf 10 1)
assert_unormal_sampler_pdf = SamplerDensity (unormal) (normalLogPdf 0 1)


assert_uniform_sampler_pdf1 = SamplerDensity (uniform 5 10) (uniformLogPdf 5 10)

assert_lognormal_pdf = SamplerDensity (logNormal 1 1) (logNormalLogPdf 1 1)
assert_gamma_pdf1 = SamplerDensity (gamma 1 2.0) (gammaLogPdf 1 2.0)
assert_gamma_pdf2 = SamplerDensity (gamma 9 0.5) (gammaLogPdf 9 0.5)

assert_invgamma_pdf1 = SamplerDensity (invGamma 1 1)   (invGammaLogPdf 1 1)
assert_invgamma_pdf2 = SamplerDensity (invGamma 3 0.5) (invGammaLogPdf 3 0.5)


--this should really be in distributiontests

rwalks = unfold 20 0 $ \x -&gt; normal x 1

assert_unfold_length = Always $ fmap (\xs -&gt; length xs == 20) rwalks

diffix ix1 ix2 xs = abs (ix ix2 xs - ix ix1 xs)

assert_rwalk = Mostly $ fmap (\xs -&gt; diffix 18 17 xs &lt; diffix 18 0 xs) rwalks

rw &lt;* sample rwalks

rw *&gt; console</pre></td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_normal_sampler_pdf1</td><td>pass</td><td>-3.0782158281191565,-2.390110711511999,-2.209321427984428,-2.1960151577013085,-2.186630539308907</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_normal_sampler_pdf3</td><td>pass</td><td>-9.46136897736346,-6.962918978415632,-6.560626382021634,-6.357341677882447,-6.093399338187244</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_normal_sampler_pdf5</td><td>pass</td><td>7.374675322816371,7.4865067000929955,7.52330501365583,7.638757473111928,7.817078162059099</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_unormal_sampler_pdf</td><td>pass</td><td>-3.5616830850998364,-3.0461732583016627,-2.871845081276328,-2.7540912348485937,-2.7435352803891124</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_uniform_sampler_pdf1</td><td>pass</td><td>5.015522348694503,5.015948002692312,5.025940302293748,5.028046590741724,5.0285676890052855</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_lognormal_pdf</td><td>pass</td><td>0.11137595005878859,0.15910060340980414,0.20976811656377187,0.2119460755376107,0.24371788656610238</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_gamma_pdf1</td><td>pass</td><td>0.0033562671815564804,0.005555997369624152,0.007850204094656081,0.01672375511456344,0.024588723199955354</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_gamma_pdf2</td><td>pass</td><td>1.550468722260538,1.5800700783854222,1.6154774378795425,1.6584017341847879,1.7951663275204248</td></tr><tr style="background-color: rgb(255, 220, 220);"><td>assert_invgamma_pdf1</td><td>fail</td><td>p=0; 0.16736939225554978,0.16802334748967104,0.18917616038282173,0.20041590160965797,0.20224673385086556</td></tr><tr style="background-color: rgb(255, 220, 220);"><td>assert_invgamma_pdf2</td><td>fail</td><td>p=0; 0.04307180751799559,0.05413323199255411,0.05425484841423991,0.05458880571446835,0.054835583069096035</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_unfold_length</td><td>pass</td><td>True,True,True,True,True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_rwalk</td><td>pass</td><td>84.6%</td></tr><tr><td><h4>RegressEstim5</h4></td><td>383 ms</td><td><a onclick="$('#RegressEstim5').toggle();" class="btn" href="javascript:void(0);">Show/hide code</a></td></tr><tr id="RegressEstim5" style="display: none;"><td colspan="3"><pre>module RegressEstim where

import Distributions.bug

samples = 10000

regress1 = prob
   offset  =  -0.5
   sigma   =  0.1
   slope   =  1
   repeat 50  $ prob w ~ intBetween 1 10
                     y ~ normal (offset+slope*(unround w)) sigma
                     return $ { foo=&gt;w;bar=&gt;y }

regress = prob
   offset  ~  normal 0 1.0
   sigma   ~  gamma 1 1
   slope   ~  normal 0.0 1.0
   repeat 50  $ prob w ~ any
                     y ~ normal (offset+slope*(unround w)) sigma
                     return $ { foo=&gt;w;bar=&gt;y }


fakedata &lt;* sample regress1

pars &lt;* estimateStan regress fakedata

assert_mean_pos = Mostly (with pars $ slope &gt; 0.5)

</pre></td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_mean_pos</td><td>pass</td><td>100%</td></tr><tr><td><h4>CovEstim</h4></td><td>10194 ms</td><td><a onclick="$('#CovEstim').toggle();" class="btn" href="javascript:void(0);">Show/hide code</a></td></tr><tr id="CovEstim" style="display: none;"><td colspan="3"><pre>module CovEstim where

import Distributions.bug

v = listToVec [1.1, 2.2, 3.3, 4.4]
cov0 = fillM (4,4) $ \(i,j) -&gt; if i==j then 0.1 else 0.0

model = prob
  vmean ~ any
  cov ~ any
  repeat 20 $ multiNormal vmean cov

model1 &lt;* updateS model $ return {vmean=&gt;v; cov =&gt; cov0}

fakeData &lt;* sample model1

pars &lt;* estimateStan model fakeData

pars *&gt; console

assert_covestim1 = Mostly (with pars $ vmean!0 &lt; 1.5)

assert_covestim2 = Mostly (with pars $ vmean!3 &gt; 4.2)

assert_covestim3 = Mostly (with pars $ cov!!(0,0) &gt; 0.01)
assert_covestim4 = Mostly (with pars $ cov!!(0,1) &lt; 0.2)</pre></td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_covestim1</td><td>pass</td><td>100%</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_covestim2</td><td>pass</td><td>99.3%</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_covestim3</td><td>pass</td><td>100%</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_covestim4</td><td>pass</td><td>98.5%</td></tr><tr><td colspan="3"><h4>MissingValues</h4></td></tr><tr style="background-color: rgb(255, 220, 220);"><td colspan="3"><pre>runtime error: 
/home/tomn/node_modules/exec-sync/bin/index.js:68
        throw new Error(error);
              ^
Error: 
Exception: variable does not exist; processing stage=data initialization; variable name=Nobs_v4; base type=int
Diagnostic information: 
Dynamic exception type: std::runtime_error
std::exception::what: variable does not exist; processing stage=data initialization; variable name=Nobs_v4; base type=int

    at module.exports (/home/tomn/node_modules/exec-sync/bin/index.js:68:15)
    at /home/tomn/baysig-exec/Baysig/Estimate/estimate.js:27:25
    at vec (/home/tomn/baysig-core/Baysig/JsBackend/trans.js:18:12)
    at pars.offset (/home/tomn/baysig-exec/tests/asserts/MissingValues.js:202:1092)
    at pars.offset (/home/tomn/baysig-exec/tests/asserts/MissingValues.js:202:1105)
    at pars.offset (/home/tomn/baysig-exec/tests/asserts/MissingValues.js:202:1111)
    at returnP.final0.w (/home/tomn/baysig-exec/tests/asserts/MissingValues.js:202:1121)
    at /home/tomn/baysig-exec/tests/asserts/MissingValues.js:202:1209
    at /home/tomn/baysig-exec/tests/asserts/MissingValues.js:202:1763
    at Object.&lt;anonymous&gt; (/home/tomn/baysig-exec/tests/asserts/MissingValues.js:202:1770)
</pre></td></tr><tr><td><h4>RegressEstim</h4></td><td>544 ms</td><td><a onclick="$('#RegressEstim').toggle();" class="btn" href="javascript:void(0);">Show/hide code</a></td></tr><tr id="RegressEstim" style="display: none;"><td colspan="3"><pre>module RegressEstim where

import Distributions.bug

samples = 10000

regress = prob
   offset  ~  normal 0 1.0
   var   ~  gamma 1 1
   slope   ~  normal 0.0 1.0
   repeat 50  $ prob w ~ uniform 0.0 1.0
                     y ~ normal (offset+slope*w) var
                     return $ { foo=&gt;w;bar=&gt;y }

regress1 &lt;* updateS regress $ return { offset=&gt; (-0.5);slope=&gt;1;sigma=&gt;0.1 }

fakedata &lt;* sample regress1

pars &lt;* estimateStan regress fakedata

plot1 = axisLabels &quot;beta_height&quot; &quot;density&quot; $ distPlot $ with pars $ slope

plot1v = axisLabels &quot;beta_height&quot; &quot;density&quot; $ distPlot $ with pars $ var

plot2 = axisLabels &quot;iteration&quot; &quot;beta_height&quot; $ chainPlot $ with pars $ slope

plot3 =  axisLabels &quot;height&quot; &quot;age&quot; $ over [plines $ with pars $ map (\{..}-&gt; (bar, offset+(foo*slope))) (fakedata),scatterPlot $ map (\{..}-&gt; (bar,foo)) (fakedata)]

plot4 = axisLabels &quot;height&quot; &quot;residuals in age&quot; $ ppoints $ with pars $ map (\{..}-&gt; (bar, foo-offset-(foo*slope))) (fakedata)


assert_mean_pos = Mostly (with pars $ slope &gt; 0.5)

</pre></td></tr><tr style="background-color: rgb(255, 220, 220);"><td>assert_mean_pos</td><td>fail</td><td>16.2%</td></tr><tr><td><h4>NestedRegression</h4></td><td>5911 ms</td><td><a onclick="$('#NestedRegression').toggle();" class="btn" href="javascript:void(0);">Show/hide code</a></td></tr><tr id="NestedRegression" style="display: none;"><td colspan="3"><pre>module RegressEstim where

import Distributions.bug

samples = 10000

nestReg = prob
   offsetmean  ~  normal 0.0 10.0
   offsetvar   ~  gamma 1 1
   slopemean   ~  normal 0 10.0
   slopevar    ~  gamma 1 1
   sigma       ~  gamma 1 1
   groups ~ repeat 20 $ prob
      slope  ~ normal slopemean slopevar
      offset ~ normal offsetmean offsetvar
      indivs ~ repeat 20 $ prob
          w ~ uniform 0.0 1.0
          y ~ normal (offset+slope*w) sigma
          return (w,y)
      return indivs
   return groups

nestReg1 &lt;* updateS nestReg $ return { offsetmean=&gt; (-2);
	    	    	      	       offsetvar=&gt; 0.1;
	    	    	      	       slopemean=&gt;1;
				       slopevar=&gt;0.1;
				       sigma=&gt;0.1 }

fakedata &lt;* sample nestReg1

pars &lt;* estimateStan nestReg fakedata

pars *&gt; console

assert_mean_pos = Mostly (with pars $ slopemean &gt; 0.5)
assert_offset_neg = Mostly (with pars $ offsetmean &lt; 0.5)

assert_nested_slope = Mostly (with pars $ (head groups)#slope &gt; 0.5)
assert_nested_offset = Mostly (with pars $ (head groups)#offset &lt; 0.0)



</pre></td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_mean_pos</td><td>pass</td><td>99.9%</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_offset_neg</td><td>pass</td><td>100%</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_nested_slope</td><td>pass</td><td>100%</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_nested_offset</td><td>pass</td><td>100%</td></tr><tr><td><h4>WildFail</h4></td><td>0 ms</td><td><a onclick="$('#WildFail').toggle();" class="btn" href="javascript:void(0);">Show/hide code</a></td></tr><tr id="WildFail" style="display: none;"><td colspan="3"><pre>module PreludeTest where

import Prelude.bug

rec1 = [{foo=&gt;(5:Int); bar=&gt;&quot;foo&quot;}]

baz = with rec1 notPresent</pre></td></tr><tr style="background-color: rgb(220, 255, 220);"><td>WildFail_must_fail</td><td>pass</td><td>Undefined variable: notPresent</td></tr><tr><td><h4>RegressEstimImproper</h4></td><td>353 ms</td><td><a onclick="$('#RegressEstimImproper').toggle();" class="btn" href="javascript:void(0);">Show/hide code</a></td></tr><tr id="RegressEstimImproper" style="display: none;"><td colspan="3"><pre>module RegressEstim where

import Distributions.bug

samples = 10000

regress0 = prob
   repeat 50  $ prob w ~ uniform 0.0 1.0
                     y ~ normal (1*w-0.5) 0.1
                     return { foo=&gt;w;bar=&gt;y }

regress = prob
   beta_0  ~  improper_uniform
   sigma   ~  gamma 1 1 
   beta_y  ~  improper_uniform
   repeat 50  $ prob w ~ uniform 0.0 1.0
                     y ~ normal (beta_0+beta_y*w) sigma
                     return $ { foo=&gt;w;bar=&gt;y }

fakedata &lt;* sample regress0

pars &lt;* estimateStan regress fakedata

assert_mean_pos = Mostly (with pars $ beta_y &gt; 0.5)

</pre></td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_mean_pos</td><td>pass</td><td>100%</td></tr><tr><td><h4>NotDefined</h4></td><td>0 ms</td><td><a onclick="$('#NotDefined').toggle();" class="btn" href="javascript:void(0);">Show/hide code</a></td></tr><tr id="NotDefined" style="display: none;"><td colspan="3"><pre>module NotFound where

import Prelude.bug

x = notDefinedAnyWhere + 1
</pre></td></tr><tr style="background-color: rgb(220, 255, 220);"><td>NotDefined_must_fail</td><td>pass</td><td>Undefined variable: notDefinedAnyWhere</td></tr><tr><td><h4>HestonEstim1</h4></td><td>6305 ms</td><td><a onclick="$('#HestonEstim1').toggle();" class="btn" href="javascript:void(0);">Show/hide code</a></td></tr><tr id="HestonEstim1" style="display: none;"><td colspan="3"><pre>module HestonCook where

import Distributions.bug
tmax = 10.0
dt = 0.01

samples= 2000

heston = prob
   k     ~ gamma 1 1
   th    ~ gamma 1 0.1
   eta   ~ gamma 1 0.1
   mu    ~ normal 0 0.1
   w1    ~ wiener
   w2    ~ wiener
   v_0   ~ gamma 1 0.1
   s_0   ~ uniform 0.0 2.0
   d v t = k * (th - v t) + eta * sqrt (v t) * d w1 t
   d s t = mu * s t + sqrt (v t) * s t * d w2 t
   return (v,s)

heston1  &lt;* updateS heston (return {  k=&gt;1.0;
                                      th=&gt;0.02;
                                      eta=&gt;0.1;
                                      mu=&gt;0.05;
                                      v_0=&gt;0.02;
                                      s_0=&gt;1.0 })



fakedata &lt;* sample heston1

pars &lt;* estimateStan heston fakedata

pars *&gt; console

assert_k_pos = Mostly (with pars $ k &gt; 0.0)




</pre></td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_k_pos</td><td>pass</td><td>100%</td></tr><tr><td><h4>LogisticCook</h4></td><td>6407 ms</td><td><a onclick="$('#LogisticCook').toggle();" class="btn" href="javascript:void(0);">Show/hide code</a></td></tr><tr id="LogisticCook" style="display: none;"><td colspan="3"><pre>module RegressCook where

import Distributions.bug

logistic = prob
   offset  ~  normal 0 2
   slope   ~  uniform (-10) 10.0
   repeat 20  $ prob   w ~ uniform 0.0 1.0
                       y ~ bernoulli(invlogit(offset+slope*w))
                       return (w,y) 
  
logisticQuantiles &lt;* cookEstimateTestStan logistic 25

assert_logistic_offset = cookAssert $ logisticQuantiles#offset
assert_logistic_slope = cookAssert $ logisticQuantiles#slope

</pre></td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_logistic_offset</td><td>pass</td><td>0.042042042042042045,0.08408408408408409,0.09109109109109109,0.12112112112112113,0.12412412412412413</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_logistic_slope</td><td>pass</td><td>0.004004004004004004,0.0980980980980981,0.17717717717717718,0.1871871871871872,0.1891891891891892</td></tr><tr><td><h4>OU</h4></td><td>3372 ms</td><td><a onclick="$('#OU').toggle();" class="btn" href="javascript:void(0);">Show/hide code</a></td></tr><tr id="OU" style="display: none;"><td colspan="3"><pre>module HestonCook where

import Distributions.bug
tmax = 10.0
dt = 0.01

samples= 2000

ou = prob
   k     ~ gamma 1 1
   th    ~ gamma 1 0.1
   eta   ~ gamma 1 0.1
   w1    ~ wiener
   v_0   ~ gamma 1 0.1
   d v t = k * (th - v t) + eta * sqrt (v t) * d w1 t
   return $ v

ou1  &lt;* updateS ou (return {  k=&gt;1.0;
                              th=&gt;0.02;
                              eta=&gt;0.1;
                              v_0=&gt;0.02})

fakedata &lt;* sample ou1

pars &lt;* estimateStan ou fakedata

--pars *&gt; console

assert_k_pos = Mostly (with pars $ k &gt; 0.0)




</pre></td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_k_pos</td><td>pass</td><td>100%</td></tr><tr><td><h4>DiffMeansCook</h4></td><td>5286 ms</td><td><a onclick="$('#DiffMeansCook').toggle();" class="btn" href="javascript:void(0);">Show/hide code</a></td></tr><tr id="DiffMeansCook" style="display: none;"><td colspan="3"><pre>module DiffMeansCook where

import Distributions.bug

samples = 5000

diffmeans = prob
    mean ~ uniform 0.0 1.0
    diff ~ uniform (-0.5) 0.5
    rvar ~ gamma 1 1
    xs ~ repeat 50 $ normal mean rvar
    ys ~ repeat 50 $ normal (mean+diff) rvar
    return (xs, ys)

              
diffmeansQuantiles &lt;* cookEstimateTestStan diffmeans 25

assert_diffmeans_mean = cookAssert $ diffmeansQuantiles#mean
assert_diffmeans_diff = cookAssert $ diffmeansQuantiles#diff
assert_diffmeans_var = cookAssert $ diffmeansQuantiles#rvar

</pre></td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_diffmeans_mean</td><td>pass</td><td>0.04083266613290633,0.07926341072858287,0.13530824659727783,0.14411529223378702,0.15852682145716573</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_diffmeans_diff</td><td>pass</td><td>0.02722177742193755,0.02802241793434748,0.0488390712570056,0.09847878302642114,0.14571657325860687</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_diffmeans_var</td><td>pass</td><td>0.016813450760608487,0.04483586869495596,0.06244995996797438,0.1321056845476381,0.17053642914331466</td></tr><tr><td><h4>RegressCook</h4></td><td>3490 ms</td><td><a onclick="$('#RegressCook').toggle();" class="btn" href="javascript:void(0);">Show/hide code</a></td></tr><tr id="RegressCook" style="display: none;"><td colspan="3"><pre>module RegressCook where

import Distributions.bug

samples = 10000

regress = prob
   offset  ~  normal 0 1.0
   sigma   ~  gamma 1 1
   slope   ~  normal 0.5 1.0
   repeat 20  $ prob w ~ uniform 0.0 1.0
                     y ~ normal (offset+slope*w) sigma
                     return (w,y) 
              
regressQuantiles &lt;* cookEstimateTestStan regress 25

assert_regress_offset = cookAssert $ regressQuantiles#offset
assert_regress_sigma = cookAssert $ regressQuantiles#sigma
assert_regress_slope = cookAssert $ regressQuantiles#slope

</pre></td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_regress_offset</td><td>pass</td><td>0.021021021021021023,0.023023023023023025,0.042042042042042045,0.05805805805805806,0.0890890890890891</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_regress_sigma</td><td>pass</td><td>0.013013013013013013,0.01701701701701702,0.018018018018018018,0.1011011011011011,0.10810810810810811</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_regress_slope</td><td>pass</td><td>0.16516516516516516,0.1871871871871872,0.25225225225225223,0.2952952952952953,0.2972972972972973</td></tr><tr><td><h4>AnovaStrings</h4></td><td>292 ms</td><td><a onclick="$('#AnovaStrings').toggle();" class="btn" href="javascript:void(0);">Show/hide code</a></td></tr><tr id="AnovaStrings" style="display: none;"><td colspan="3"><pre>module RegressEstim where

import Distributions.bug

samples = 10000

regress = prob
   nlondon ~  improper_uniform
   nbeeston   ~ improper_uniform
   vari ~ gamma 1 1 
   repeat 50  $ prob c ~ any
                     n ~ normal (boolToReal (c == &quot;London&quot;) * nlondon + boolToReal (c == &quot;nodnoL&quot;) * nbeeston) vari
                     return { city=&gt;c;noise=&gt;n }

regress1 = 
   repeat 50  $ prob c ~ oneOf [&quot;London&quot;, &quot;nodnoL&quot;]
                     n ~ normal (if c == &quot;London&quot; then 50 else 30) 20
                     return { city=&gt;c;noise=&gt;n }

fakedata &lt;* sample regress1

fakedata *&gt; console

pars &lt;* estimateStan regress fakedata

nlon = with pars nlondon

nlon *&gt; console

nbee = with pars nbeeston

nbee *&gt; console

assert_mean_pos = Mostly (with pars $ between 45 55 $ nlondon)

</pre></td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_mean_pos</td><td>pass</td><td>100%</td></tr><tr><td><h4>Update</h4></td><td>115 ms</td><td><a onclick="$('#Update').toggle();" class="btn" href="javascript:void(0);">Show/hide code</a></td></tr><tr id="Update" style="display: none;"><td colspan="3"><pre>module Update where

import Distributions.bug

upsampler = prob
   mean ~ uniform 3 4
   return mean


upsampler1 &lt;* updateS upsampler $ return { mean=&gt; 1}

upsample &lt;* sample upsampler1

assert_update = between 0.5 1.5 upsample


ss &lt;* sample (repeat 10 upsampler1)

--ss *&gt; console</pre></td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_update</td><td>pass</td><td>True</td></tr><tr><td><h4>Constructor</h4></td><td>0 ms</td><td><a onclick="$('#Constructor').toggle();" class="btn" href="javascript:void(0);">Show/hide code</a></td></tr><tr id="Constructor" style="display: none;"><td colspan="3"><pre>module Constructor where

import Prelude.bug

x = Cons 5 $ Cons &quot;foo&quot; Nil</pre></td></tr><tr style="background-color: rgb(220, 255, 220);"><td>Constructor_must_fail</td><td>pass</td><td>String is not a member of type class Num in x</td></tr><tr><td><h4>RegressDVarCook</h4></td><td>4329 ms</td><td><a onclick="$('#RegressDVarCook').toggle();" class="btn" href="javascript:void(0);">Show/hide code</a></td></tr><tr id="RegressDVarCook" style="display: none;"><td colspan="3"><pre>module RegressDVarCook where

import Distributions.bug

samples = 10000

regress = prob
   offset  ~  uniform 1.0 5.0
   sigma   ~  gamma 1 1
   slope1  ~  uniform (-0.5) 1.0
   slope   =  exp slope1
   repeat 20  $ prob w ~ uniform 0.0 1.0
                     y ~ normal (offset+slope*w) sigma
                     return (w,y) 
              
regressQuantiles &lt;* cookEstimateTestStan regress 25

assert_regressD_offset = cookAssert $ regressQuantiles#offset
assert_regressD_sigma  = cookAssert $ regressQuantiles#sigma
assert_regressD_slope1 = cookAssert $ regressQuantiles#slope1

</pre></td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_regressD_offset</td><td>pass</td><td>0.03003003003003003,0.04804804804804805,0.0920920920920921,0.28128128128128127,0.2962962962962963</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_regressD_sigma</td><td>pass</td><td>0.09509509509509509,0.12912912912912913,0.16816816816816818,0.18018018018018017,0.2012012012012012</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_regressD_slope1</td><td>pass</td><td>0.0990990990990991,0.12212212212212212,0.14114114114114115,0.15315315315315314,0.15515515515515516</td></tr><tr><td><h4>BugsessTest</h4></td><td>144 ms</td><td><a onclick="$('#BugsessTest').toggle();" class="btn" href="javascript:void(0);">Show/hide code</a></td></tr><tr id="BugsessTest" style="display: none;"><td colspan="3"><pre>module BugsessTest where

import Prelude.bug

--ASSERT_TYPE five Int

five &lt;* fetch &quot;testdb/five&quot;

rec &lt;* fetch &quot;testdb/testrec&quot;

rec1 &lt;* fetch &quot;testdb/morerec&quot;

probrec &lt;* fetch &quot;testdb/probrec&quot;

assert_fetch1 = five == 5

--ASSERT_TYPE rec {age: Int; name: String}
--assert_name = rec#name == &quot;Tom&quot;
assert_age = rec#age == 35
assert_age1 = 35 == rec#age
assert_deep_age = rec1#sub2#zoo#age == 35
assert_stored_signal = between 0 2 $ (rec1#sub2#baz) 0.2

--ASSERT_TYPE probrec (Prob {foo: Real; bar: Real})
assert_prob_fetch = Mostly $ with probrec $ foo &lt; 1.0

root &lt;* fetch &quot;testdb/morerec&quot;

assert_root1 = root#sub2#zoo#age == 35
assert_root2 = #sub2#zoo#age == 35
assert_root3 = 35 == #sub2#zoo#age 
assert_root4 = #sub3 &gt; 3 &amp;&amp;  #sub3 &lt; 4 

assert_stored_just = case #sub4 of
                      Cons (Just x) _ -&gt; x == 1
                      _ -&gt; False 

{- This takes ages to typecheck:
assert_stored_maybe = case ix 1 (#sub4) of
                         Nothing -&gt; True
                         _ -&gt; False 
-}
myMat &lt;* fetch &quot;testdb/amat&quot;

--assert_mat1 = (myMat !! (0,1)) == 1 
--assert_mat2 = (myMat !! (1,0)) == 2

</pre></td></tr><tr style="background-color: rgb(220, 255, 220);"><td>asserted_type_of_five</td><td>pass</td><td>Int</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>asserted_type_of_rec</td><td>pass</td><td>{age:Int, name:String}</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>asserted_type_of_probrec</td><td>pass</td><td>Prob {foo:Real, bar:Real}</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_fetch1</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_age</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_age1</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_deep_age</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_stored_signal</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_prob_fetch</td><td>pass</td><td>84%</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_root1</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_root2</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_root3</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_root4</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_stored_just</td><td>pass</td><td>True</td></tr><tr><td><h4>Add</h4></td><td>0 ms</td><td><a onclick="$('#Add').toggle();" class="btn" href="javascript:void(0);">Show/hide code</a></td></tr><tr id="Add" style="display: none;"><td colspan="3"><pre>module Add where

import Prelude.bug

{-
    correct method for typechecking this definition:
    1. we assume that `+&#39; is of type Int -&gt; Int -&gt; Int or equivalent
    2. we can think of the expression as ((+ 5) &quot;foo&quot;)
    3. we begin with the whole expression, detect that it&#39;s an application
       and continue with the left sub-expression
    4. we now need to infer the type of (+ 5) which is another application,
       so we continue with the left sub-expression
    5. `+&#39; is a variable which has type Int -&gt; (Int -&gt; Int) in the context
    6. 5 is a literal of type Int which matches the parameter of `+&#39;
    7. (+ 5) is of type Int -&gt; Int
    8. &quot;foo&quot; is a literal of type String which doesn&#39;t match the expected type Int
       and there exists no way of unifying these two types
    9. the expression is therefore incorrectly typed
-}

x = 5 + &quot;foo&quot;</pre></td></tr><tr style="background-color: rgb(220, 255, 220);"><td>Add_must_fail</td><td>pass</td><td>String is not a member of type class Num in x</td></tr><tr><td><h4>DiffMeansEstim1</h4></td><td>354 ms</td><td><a onclick="$('#DiffMeansEstim1').toggle();" class="btn" href="javascript:void(0);">Show/hide code</a></td></tr><tr id="DiffMeansEstim1" style="display: none;"><td colspan="3"><pre>module DiffMeansEstim where

import Distributions.bug

samples = 5000

myPriorMean = normal 0.0 1.0
myPriorDiff = uniform (-0.5) 0.5

diffmeans pmean pdiff = prob
    mean ~ pmean
    diff ~ pdiff
    rvar ~ gamma 1 1
    xs ~ repeat 50 $ normal mean rvar
    ys ~ repeat 50 $ normal (mean+diff) rvar
    return { foo =&gt;xs; bar =&gt; ys }

diffmeans2 &lt;* updateS (diffmeans myPriorMean myPriorDiff) $ return { mean=&gt; 0.5;diff=&gt;0.3;rvar=&gt;0.1 }

diffmeans1 = diffmeans myPriorMean myPriorDiff

diffmeans3 &lt;* updateS diffmeans1 $ return { mean=&gt; 0.5;diff=&gt;0.3;rvar=&gt;0.1 }

fakedata &lt;* sample diffmeans2

pars &lt;* estimateStan (diffmeans myPriorMean myPriorDiff) fakedata

assert_mean_pos = Always (with pars $ mean &gt; 0.0)

assert_diff_pos = Mostly (with pars $ diff &gt; 0.1)</pre></td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_mean_pos</td><td>pass</td><td>True,True,True,True,True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_diff_pos</td><td>pass</td><td>100%</td></tr><tr><td><h4>OUxy</h4></td><td>2082 ms</td><td><a onclick="$('#OUxy').toggle();" class="btn" href="javascript:void(0);">Show/hide code</a></td></tr><tr id="OUxy" style="display: none;"><td colspan="3"><pre>module HestonCook where

import Distributions.bug
tmax = 10.0
dt = 0.01

samples= 2000

ou = prob
   k     ~ gamma 1 1
   th    ~ gamma 1 0.1
   eta   ~ gamma 1 0.1
   w1    ~ wiener
   v_0   ~ gamma 1 0.1
   d v t = k * (th - v t) + eta * sqrt (v t) * d w1 t
   return $ v

ou1  &lt;* updateS ou (return {  k=&gt;1.0;
                              th=&gt;0.02;
                              eta=&gt;0.1;
                              v_0=&gt;0.02})

fakedata &lt;* sample ou1

fakedata *&gt; console

o = let (ObservedSignal _ _ pts) = observeSig fakedata
    in vecToList pts



tms = map (\i -&gt; 0.01*unround i) $ fromTo 0 1000

pars &lt;* estimateStan ou (packXYL (zip tms o))

pars *&gt; console

assert_k_pos = Mostly (with pars $ k &gt; 0.0)




</pre></td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_k_pos</td><td>pass</td><td>100%</td></tr><tr><td><h4>RegressEstim3</h4></td><td>4770 ms</td><td><a onclick="$('#RegressEstim3').toggle();" class="btn" href="javascript:void(0);">Show/hide code</a></td></tr><tr id="RegressEstim3" style="display: none;"><td colspan="3"><pre>module RegressEstim where

import Distributions.bug

samples = 10000

regress = prob
    beta_0 ~ improper_uniform
    beta_age ~ improper_uniform
    beta_male ~ improper_uniform
    beta_salaryhr ~ improper_uniform
    variance ~ gamma 1 1
    repeat 50 $ prob
       age ~ improper_uniform
       male ~ bernoulli 0.5
       salaryhr ~ binomial 50 0.5
       height ~ normal (((beta_0+(age*beta_age))+((boolToReal male)*beta_male))+((unround salaryhr)*beta_salaryhr)) variance
       return $ { height=&gt;height;age=&gt;age;male=&gt;male;salaryhr=&gt;salaryhr }

regress2 = prob
    beta_0 ~ improper_uniform
    beta_age ~ improper_uniform
    beta_male ~ improper_uniform
    beta_salaryhr ~ improper_uniform
    variance ~ gamma 1 1
    repeat 50 $ prob
       age ~ any
       male ~ any
       salaryhr ~ any
       height ~ normal (((beta_0+(age*beta_age))+((boolToReal male)*beta_male))+((unround salaryhr)*beta_salaryhr)) variance
       return { height=&gt;height;age=&gt;age;male=&gt;male;salaryhr=&gt;salaryhr }

regress1 = prob
    repeat 50 $ prob
       age ~ normal 30 5
       male ~ bernoulli 0.5
       salaryhr ~ binomial 50 0.5
       height ~ normal (((4.0+(age*2.0))+((boolToReal male)*0.0))+((unround salaryhr)*0.5)) 1.0
       return { height=&gt;height;age=&gt;age;male=&gt;male;salaryhr=&gt;salaryhr;name=&gt;&quot;foo&quot;}

fakedata &lt;* sample regress1

pars &lt;* estimateStan regress fakedata

pars2 &lt;* estimateStan regress2 fakedata

assert_slope_posterior = Mostly (with pars $ beta_age &gt; 0.5)
assert_slope_posterior2 = Mostly (with pars2 $ beta_age &gt; 0.5)

</pre></td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_slope_posterior</td><td>pass</td><td>100%</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_slope_posterior2</td><td>pass</td><td>100%</td></tr><tr><td><h4>HestonEstim3</h4></td><td>73239 ms</td><td><a onclick="$('#HestonEstim3').toggle();" class="btn" href="javascript:void(0);">Show/hide code</a></td></tr><tr id="HestonEstim3" style="display: none;"><td colspan="3"><pre>module HestonCook where

import Distributions.bug
tmax = 5.0
dt = 0.01

samples= 2000

heston = prob
   kappa ~ improper_uniform_positive
   mu ~ improper_uniform
   theta ~ improper_uniform_positive
   xi ~ improper_uniform_positive
   w0 ~ wiener
   w1 ~ wiener
   s_0 ~ improper_uniform_positive
   nu_0 ~ improper_uniform_positive
   d s t = (mu*(s t))+(((sqrt (nu t))*(s t))*(d w0 t))
   d nu t = (kappa*(theta-(nu t)))+((xi*(sqrt (nu t)))*(d w1 t))
   return {s=&gt; s; nu=&gt; nu}

heston1  &lt;* updateS heston (return {  kappa=&gt;1.0;
                                      theta=&gt;0.02;
                                      xi=&gt;0.1;
                                      mu=&gt;0.05;
                                      nu_0=&gt;0.02;
                                      s_0=&gt;1.0})

fakedata &lt;* sample heston1

pars &lt;* estimateStan heston {s=&gt;fakedata#s}

pars *&gt; console

assert_k_pos = Mostly (with pars $ kappa &gt; 0.0)

assert_v_pos = Mostly (with pars $ nu 5.0 &gt; 0.0) 

hestonForward &lt;* fastForward heston pars {s=&gt;fakedata#s}

future &lt;* sample hestonForward

(future#s) 5.0 *&gt; console
(future#nu) 5.0 *&gt; console

assert_fast_forward = (future#s) 0.1 &gt; 0

td = with hestonForward (s 5.0)

--td0 &lt;* sample $ repeat 50 td

td *&gt; console

plt = psigPlot $ with hestonForward s 

</pre></td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_k_pos</td><td>pass</td><td>100%</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_v_pos</td><td>pass</td><td>100%</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_fast_forward</td><td>pass</td><td>True</td></tr><tr><td><h4>VecMatTests</h4></td><td>111 ms</td><td><a onclick="$('#VecMatTests').toggle();" class="btn" href="javascript:void(0);">Show/hide code</a></td></tr><tr id="VecMatTests" style="display: none;"><td colspan="3"><pre>module VecMatTests where

import Prelude.bug

m = fillM (10,10) $ \(i,j) -&gt; unround i * unround j

v = fillV 5 $ \i -&gt; unround i +4

assert_vec_dim = dim v == 5

assert_mat_ix = m !! (2,2) &lt; 10.0 
assert_vec_ix = v ! 2 &lt; 9.0 

m1 = fillM (2,5) $ \(i,j) -&gt; unround i * unround j

assert_mdims = fst (mdims m1) == 2 &amp;&amp; snd (mdims m1) == 5
</pre></td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_vec_dim</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_mat_ix</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_vec_ix</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_mdims</td><td>pass</td><td>True</td></tr><tr><td><h4>VectorEstim</h4></td><td>4301 ms</td><td><a onclick="$('#VectorEstim').toggle();" class="btn" href="javascript:void(0);">Show/hide code</a></td></tr><tr id="VectorEstim" style="display: none;"><td colspan="3"><pre>module VectorEstim where

import Distributions.bug

v = listToVec [1.1, 2.2, 3.3, 4.4]

model = prob
  vmean ~ any
  sigma ~ gamma 1 1 
  cov = fillM (4,4) $ \(i,j) -&gt; if i==j then sigma else 0.0
  repeat 20 $ multiNormal vmean cov

model1 &lt;* updateS model $ return {vmean=&gt;v; sigma =&gt; 0.001}

fakeData &lt;* sample model1


pars &lt;* estimateStan model fakeData

assert_vestim1 = Mostly (with pars $ vmean!0 &lt; 1.5)

assert_vestim2 = Mostly (with pars $ vmean!3 &gt; 4.2)

assert_vestim3 = Mostly (with pars $ sigma &lt; 0.01)</pre></td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_vestim1</td><td>pass</td><td>100%</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_vestim2</td><td>pass</td><td>100%</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_vestim3</td><td>pass</td><td>100%</td></tr><tr><td><h4>RegressEstim1</h4></td><td>377 ms</td><td><a onclick="$('#RegressEstim1').toggle();" class="btn" href="javascript:void(0);">Show/hide code</a></td></tr><tr id="RegressEstim1" style="display: none;"><td colspan="3"><pre>module RegressEstim where

import Distributions.bug

samples = 10000

regress = prob
   offset  ~  normal 0 1.0
   sigma   ~  gamma 1 1
   slope   ~  normal 0.0 1.0
   repeat 50  $ prob w ~ uniform 0.0 1.0
                     y ~ normal (offset+slope*w) sigma
                     return { w=&gt;w;y=&gt;y }

regress1 = 
   repeat 50  $ prob w ~ uniform 0.0 1.0
                     y ~ normal (1*w-0.5) 0.1
                     return { w=&gt;w;y=&gt;y;foo=&gt;3.1 }

fakedata &lt;* sample regress1

pars &lt;* estimateStan regress fakedata

assert_mean_pos = Mostly (with pars $ slope &gt; 0.5)

</pre></td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_mean_pos</td><td>pass</td><td>100%</td></tr><tr><td><h4>wctest</h4></td><td>123 ms</td><td><a onclick="$('#wctest').toggle();" class="btn" href="javascript:void(0);">Show/hide code</a></td></tr><tr id="wctest" style="display: none;"><td colspan="3"><pre>module WCTest where

import Prelude.bug

-- Ian&#39;s wildcard problemS...

----------------------------------------------------------------------

a = &quot;global a&quot;
a11 = { a =&gt; &quot;a11#a&quot;; b =&gt; &quot;a11#b&quot; }
a12 = { a =&gt; &quot;a12#a&quot;; b =&gt; &quot;a12#b&quot; }
a1s = [a11, a12]
a21 = { a =&gt; a11; b =&gt; &quot;a21#b&quot; }
a22 = { a =&gt; a12; b =&gt; &quot;a22#b&quot; }
a2s = [a21, a22]

assert_a = a == &quot;global a&quot;


assert_a11a = a11#a == &quot;a11#a&quot;

assert_a21aa = a21#a#a == &quot;a11#a&quot;
assert_a21ab = a21#a#b == &quot;a11#b&quot;


tst1chk1 = map (\r -&gt; r#a) a1s
tst1chk1 *&gt; console
-- OK: tst1chk1 =&gt; [&quot;a11#a&quot;, &quot;a12#a&quot;]

assert_tst1chk1_1 = head tst1chk1 == &quot;a11#a&quot;
assert_tst1chk1_2 = ix 1 tst1chk1 == &quot;a12#a&quot;


tst1chk2 = map (\{..} -&gt; a) a1s
tst1chk2 *&gt; console

assert_tst1chk2_1 = head tst1chk2 == &quot;a11#a&quot;
assert_tst1chk2_2 = ix 1 tst1chk2 == &quot;a12#a&quot;

-- OK: tst1chk2 =&gt; [&quot;a11#a&quot;, &quot;a12#a&quot;]

tst1 = with a1s a
tst1 *&gt; console
-- OK: tst1 =&gt; [&quot;a11#a&quot;, &quot;a12#a&quot;]

assert_tst1_1 = head tst1 == &quot;a11#a&quot;
assert_tst1_2 = ix 1 tst1 == &quot;a12#a&quot;

--(with a1s a) *&gt; console
-- FAIL: bays: Baysig/JsBackend/Match.hs:(19,1)-(35,98): Non-exhaustive patterns in function match
-- SHOULD GIVE: [&quot;a11#a&quot;, &quot;a12#a&quot;]

tst2chk1 = map (\r -&gt; r#a) a2s
tst2chk1 *&gt; console
-- OK: tst2chk1 =&gt; [{a =&gt; &quot;a11#a&quot;;b =&gt; &quot;a11#b&quot;;}, {a =&gt; &quot;a12#a&quot;;b =&gt; &quot;a12#b&quot;;}]

tst2chk2 = map (\{..} -&gt; a) a2s
tst2chk2 *&gt; console
-- FAIL: bays: user error (type error in wctest.bug: cannot unify: String and {a:String, b:String} in tst2chk2)
-- SHOULD GIVE: tst2chk2 =&gt; [{a =&gt; &quot;a11#a&quot;;b =&gt; &quot;a11#b&quot;;}, {a =&gt; &quot;a12#a&quot;;b =&gt; &quot;a12#b&quot;;}]

tst2 = with a2s a
tst2 *&gt; console
-- FAIL: bays: user error (type error in wctest.bug: cannot unify: String and {a:String, b:String} in tst2)
-- SHOULD GIVE: tst2 =&gt; [{a =&gt; &quot;a11#a&quot;;b =&gt; &quot;a11#b&quot;;}, {a =&gt; &quot;a12#a&quot;;b =&gt; &quot;a12#b&quot;;}]


----------------------------------------------------------------------

-- This next one ultimately won&#39;t work because of the problem shown
-- above, but it was going to be my next test case, and there is
-- another problem that turns up along the way...

r1 = { a =&gt; &quot;r1#a&quot;; b =&gt; &quot;r1#b&quot; }
r2 = { a =&gt; r1; b =&gt; &quot;r2#b&quot; }
r3 = { a =&gt; r2; b =&gt; &quot;r3#b&quot; }

tst3chk1 = with [r1] b
tst3chk1 *&gt; console

assert_tst3chk1 = head tst3chk1 == &quot;r1#b&quot;
-- OK: tst3chk1 =&gt; [&quot;r1#b&quot;]

tst3chk2 = with [r2] b
tst3chk2 *&gt; console

assert_tst3chk2 = head tst3chk2 == &quot;r2#b&quot;

tst3 = with [r3] b
tst3 *&gt; console

assert_tst3 = head tst3 == &quot;r3#b&quot;

r3s = [r3]

r3s *&gt; console

tst5 = with [r3] a
tst5 *&gt; console

--tst4 = with (with r3s a) a
--tst4 *&gt; console
-- FAIL: bays: user error (type error in wctest.bug: cannot unify: {a:String, b:String} and String in tst4)

r4 = [{foo =&gt; [{bar =&gt; True;baz=&gt; 1.0}]; boo=&gt; &quot;hiss&quot;}]

foos = with r4 foo

r2as = with [r2] a
r2as *&gt; console

[r2] *&gt; console

--tst6 = with (with [r2] a) a

tst7 = with [r2] $ a#a

tst7 *&gt; console

tst8 = with [r3] $ a#a#a

assert_tst8 = head tst8 == &quot;r1#a&quot;
assert_tst7 = head tst7 == &quot;r1#a&quot;


</pre></td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_a</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_a11a</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_a21aa</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_a21ab</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_tst1chk1_1</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_tst1chk1_2</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_tst1chk2_1</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_tst1chk2_2</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_tst1_1</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_tst1_2</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_tst3chk1</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_tst3chk2</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_tst3</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_tst8</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_tst7</td><td>pass</td><td>True</td></tr><tr><td><h4>RegressEstim2</h4></td><td>1504 ms</td><td><a onclick="$('#RegressEstim2').toggle();" class="btn" href="javascript:void(0);">Show/hide code</a></td></tr><tr id="RegressEstim2" style="display: none;"><td colspan="3"><pre>module RegressEstim where

import Distributions.bug

samples = 10000

regress = prob
   offset  ~  normal 0 1.0
   sigma   ~  gamma 1 1
   slope   ~  normal 0.0 1.0
   repeat 50  $ prob w ~ uniform 0.0 1.0
                     z ~ normal 0 0.05
                     y ~ normal (offset+slope*w+z) sigma
                     return $ { w=&gt;w;y=&gt;y;z=&gt;z }

regress1 = 
   repeat 50  $ prob w ~ uniform 0.0 1.0
                     y ~ normal (1*w-0.5) 0.1
                     return $ { w=&gt;w;y=&gt;y;foo=&gt;3.1 }

fakedata &lt;* sample regress1

pars &lt;* estimateStan regress fakedata

assert_slope_posterior = Mostly (with pars $ slope &gt; 0.5)

</pre></td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_slope_posterior</td><td>pass</td><td>100%</td></tr><tr><td><h4>DiffMeansEstim</h4></td><td>349 ms</td><td><a onclick="$('#DiffMeansEstim').toggle();" class="btn" href="javascript:void(0);">Show/hide code</a></td></tr><tr id="DiffMeansEstim" style="display: none;"><td colspan="3"><pre>module DiffMeansEstim where

import Distributions.bug

samples = 5000

diffmeans = prob
    mean ~ uniform 0.0 1.0
    diff ~ uniform (-0.5) 0.5
    rvar ~ gamma 1 1
    xs ~ repeat 50 $ normal mean rvar
    ys ~ repeat 50 $ normal (mean+diff) rvar
    return { foo =&gt;xs; bar =&gt; ys }

diffmeans1 &lt;* updateS diffmeans $ return { mean=&gt; 0.5;diff=&gt;0.3;rvar=&gt;0.1 }

fakedata &lt;* sample diffmeans1

pars &lt;* estimateStan diffmeans fakedata

assert_mean_pos = Always (with pars $ mean &gt; 0.0)

assert_diff_pos = Mostly (with pars $ diff &gt; 0.1)</pre></td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_mean_pos</td><td>pass</td><td>True,True,True,True,True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_diff_pos</td><td>pass</td><td>100%</td></tr><tr><td><h4>CoinBias</h4></td><td>220 ms</td><td><a onclick="$('#CoinBias').toggle();" class="btn" href="javascript:void(0);">Show/hide code</a></td></tr><tr id="CoinBias" style="display: none;"><td colspan="3"><pre>module CoinBias where

import Distributions.bug

model = prob
  bias ~ beta 1 1
  repeat 20 $ bernoulli bias

model1 &lt;* updateS model $ return { bias=&gt;0.6 }

fakeData &lt;* sample model1

pars &lt;* estimateStan model fakeData

assert_coin = Mostly $ with pars (bias&gt;0.5)</pre></td></tr><tr style="background-color: rgb(255, 220, 220);"><td>assert_coin</td><td>fail</td><td>3.2%</td></tr><tr><td><h4>RegressEstim4</h4></td><td>543 ms</td><td><a onclick="$('#RegressEstim4').toggle();" class="btn" href="javascript:void(0);">Show/hide code</a></td></tr><tr id="RegressEstim4" style="display: none;"><td colspan="3"><pre>module RegressEstim where

import Distributions.bug

samples = 10000

regress = prob
   offset  ~  logNormal 1.0 1.0
   sigma   ~  invGamma 1 1
   slope   ~  normal 0.0 1.0
   repeat 50  $ prob w ~ uniform 0.0 1.0
                     y ~ logNormal (offset+slope*w) sigma
                     return $ { foo=&gt;w;bar=&gt;y }

regress1 &lt;* updateS regress $ return { offset=&gt; 1.0;slope=&gt;1;sigma=&gt;0.1 }

fakedata &lt;* sample regress1

pars &lt;* estimateStan regress fakedata

assert_mean_pos = Mostly (with pars $ slope &gt; 0.5)

</pre></td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_mean_pos</td><td>pass</td><td>99.9%</td></tr><tr><td><h4>RegressCook1</h4></td><td>8902 ms</td><td><a onclick="$('#RegressCook1').toggle();" class="btn" href="javascript:void(0);">Show/hide code</a></td></tr><tr id="RegressCook1" style="display: none;"><td colspan="3"><pre>module RegressEstim where

import Distributions.bug

samples = 10000

regress = prob
   offset  ~  logNormal 1.0 1.0
   sigma   ~  invGamma 1 1
   slope   ~  normal 0.0 1.0
   repeat 5  $ prob w ~ uniform 0.0 1.0
                    y ~ logNormal (offset+slope*w) sigma
                    return $ { foo=&gt;w;bar=&gt;y }

regressQuantiles &lt;* cookEstimateTestStan regress 100

assert_regress_offset = cookAssert $ regressQuantiles#offset
assert_regress_sigma = cookAssert $ regressQuantiles#sigma
assert_regress_slope = cookAssert $ regressQuantiles#slope

</pre></td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_regress_offset</td><td>pass</td><td>0.02002002002002002,0.03303303303303303,0.03403403403403404,0.03403403403403404,0.06406406406406406</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_regress_sigma</td><td>pass</td><td>0.007007007007007007,0.011011011011011011,0.012012012012012012,0.014014014014014014,0.028028028028028028</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_regress_slope</td><td>pass</td><td>0.005005005005005005,0.021021021021021023,0.022022022022022022,0.022022022022022022,0.02902902902902903</td></tr></table></div></div></div></body></html>