<!DOCTYPE HTML>
<html><head><title>08March2013_132511</title><script src="https://ajax.googleapis.com/ajax/libs/jquery/1.9.0/jquery.min.js"></script></head><body><h2>08March2013_132511</h2><table><tr><th>package</th><th>git commit hash</th><th>modified</th></tr><tr><td>baysig-core</td><td>1698108e6610e9d8fe3d00c7958e5af69e13335c
</td><td></td></tr><tr><td>bugsess</td><td>acf9889e71f05f999f5ad429a76dc9722e3fefd9
</td><td></td></tr><tr><td>baysig-exec</td><td>48d5b29b5da78ebeb7c02f6d2fd67060edeeeacf
</td><td></td></tr></table><table><tr><td colspan="3"><h4>DistributionTest</h4></td></tr><tr style="background-color: rgb(255, 220, 220);"><td colspan="3"><pre>type error: Undefined variable: decide</pre></td></tr><tr><td><h4>LogisticEstim1</h4></td><td>398 ms</td><td><a onclick="$('#LogisticEstim1').toggle();" href="javascript:void(0);">Show/hide code</a></td></tr><tr id="LogisticEstim1" style="display: none;"><td colspan="3"><pre>module RegressCook where

import Distributions.bug

logistic = prob
   offset  ~  normal 0 2
   slope   ~  uniform (-10) 10.0
   repeat 20  $ prob   w ~ uniform 0.0 1.0
                       y ~ bernoulli01(invlogit(offset+slope*w))
                       return (w,y) 
  
logistic1 &lt;* updateN logistic $ return ( offset =&gt; (-2.0);
					 slope =&gt; 4.0)

fakeData &lt;* sample logistic1

logitPars &lt;* estimateStan logistic fakeData

assert_mean_pos = Mostly (with logitPars $ slope &gt; 0.5)
            

</pre></td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_mean_pos</td><td>pass</td><td>90.8%</td></tr><tr><td><h4>PreludeTests</h4></td><td>86 ms</td><td><a onclick="$('#PreludeTests').toggle();" href="javascript:void(0);">Show/hide code</a></td></tr><tr id="PreludeTests" style="display: none;"><td colspan="3"><pre>module PreludeTest where

import Prelude.bug

assert_fac3 = fac 3 == 6

assert_pairs0 = 2 == fst (2,3)
assert_pairs1 = 3 == snd (2,3)

assert_case = case 1 of
        0 -&gt; False
        1 -&gt; True

assert_case1 = case 1 of
        0 -&gt; False
        _ -&gt; True

assert_case2 = case 1 of
        0 -&gt; False
        x -&gt; True

assert_case3 = not $ case 0 of
        0 -&gt; False
        x -&gt; True

f x = 2 * x + 1

lst = Cons 5.3 $ Cons 2.1 Nil

nothing_to_see = let &lt;x,y,z&gt; = fillV 3 (\i-&gt; unround i)
	       	 in ()

--ASSERT_TYPE lst (List Real)

assert_fhead = between 10 12 $ f $ head lst

assert_bool1 = (True &amp;&amp; False) || (True || False)

assert_bool2 = not $ (True &amp;&amp; False) || (True &amp;&amp; False)

assert_cmp = if ((f $ head lst) &gt; 10) then True else False

assert_negative = -5 &lt; 0

assert_length1 = length lst == 2

lst_lit = [6.2, 4.5, 8.9]

assert_length2 = length lst_lit == 3

asset_litlist1 = between 6 7 $ ix 0 lst_lit
asset_litlist2 = between 8 9 $ ix 2 lst_lit

llpat = let [x,y] = lst
        in x

assert_list_lit_pattern = between 5 6 llpat




--the mere definition of these makes the test suite loop forever. not good. 
--commenting out pred-prey code fixes this. 
--wierd interaction between mutually recursive functions and ODEs
--FIXME

--myeven 0 = True
--myeven n =  myodd (n-1)

--myodd 0 = False
--myodd n = myeven (n-1)



--simple distributions

fixdist = prob
  x ~ return (4:Int)
  y ~ return 5
  return (x + y)

fixdist1 = prob
  x ~ return (4:Int)
  y ~ return 5
  w = x + y
  return (w + y)

nestedDo = prob
  x ~ prob 
    z ~ unit
    return z
  return $ x+1

fixdistSam &lt;* sample $ fmap (\w-&gt;w&gt;6) fixdist
fixdist1Sam &lt;* sample $ fmap (\w-&gt;w&gt;10) fixdist1
nestedDoSam &lt;* sample $ fmap (\w-&gt;w&gt;1.0) nestedDo

assert_fixdist = fixdistSam
assert_fixdist1 = fixdist1Sam
assert_nestedDo = nestedDoSam



wdist = return ( xr =&gt; 2 )

wdistSam &lt;* sample $ with wdist (between 1 3 xr) 
assert_with = wdistSam


-- records

--ASSERT_TYPE rec1 {foo: Int; bar: String}

rec1 = foo =&gt; (5:Int);bar=&gt;&quot;Hello!&quot;

assert_rec_access1 = rec1#foo &gt; 4

rec2 = baz=&gt;True
--doesnt work for now: rec2 = rec1;baz=&gt;True or rec2 = baz=&gt;True;rec1

assert_rec_access2= rec2#baz

rec1foo = let {..} = rec1
	  in foo

assert_rec1_wild = between 4 6 rec1foo


--implicit parameters


fimpl foo? bar = foo+(bar:Int)

impl_res = let foo = 2
           in fimpl 5

assert_implicit_params = impl_res == 7
	 

pair_num_list = (3, [5])

assert_pair_num_list = fst pair_num_list == 3
</pre></td></tr><tr style="background-color: rgb(220, 255, 220);"><td>asserted_type_of_lst</td><td>pass</td><td>List Real</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>asserted_type_of_rec1</td><td>pass</td><td>{foo:Int, bar:String}</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_fac3</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_pairs0</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_pairs1</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_case</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_case1</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_case2</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_case3</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_fhead</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_bool1</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_bool2</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_cmp</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_negative</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_length1</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_length2</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_list_lit_pattern</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_pair_num_list</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_rec_access1</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_rec_access2</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_rec1_wild</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_implicit_params</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_fixdist</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_fixdist1</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_nestedDo</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_with</td><td>pass</td><td>True</td></tr><tr><td><h4>RecursiveTests</h4></td><td>83 ms</td><td><a onclick="$('#RecursiveTests').toggle();" href="javascript:void(0);">Show/hide code</a></td></tr><tr id="RecursiveTests" style="display: none;"><td colspan="3"><pre>module RecursiveTests where

import Prelude.bug


myeven 0 = True
myeven n =  myodd (n-1)

myodd 0 = False
myodd n = myeven (n-1)

myeven1 0 = True
myeven1 n =  myodd1 (n-1)

myodd1 0 = False
myodd1 n = myeven1 (n-1)


assert_even_4 = myeven 4
assert_even1_4 = myeven1 4
assert_odd_5 = myodd 5
assert_odd1_5 = myodd 5
assert_noteven_5 = not $ myeven 5

</pre></td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_even_4</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_even1_4</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_odd_5</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_odd1_5</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_noteven_5</td><td>pass</td><td>True</td></tr><tr><td><h4>HestonEstim</h4></td><td>162672 ms</td><td><a onclick="$('#HestonEstim').toggle();" href="javascript:void(0);">Show/hide code</a></td></tr><tr id="HestonEstim" style="display: none;"><td colspan="3"><pre>module HestonCook where

import Distributions.bug
tmax = 10.0
dt = 0.01

samples= 2000

heston = prob
   k        ~ gamma 1 1
   th       ~ gamma 1 0.1
   eta      ~ gamma 1 0.1
   mu       ~ normal 0 0.1
   w1       ~  wiener
   w2       ~  wiener
   v_0      ~  gamma 1 0.1
   s_0      ~  uniform 0.0 2.0
   d v t = k * (th - v t) + eta * sqrt (v t) * d w1 t
   d s t = mu * s t + sqrt (v t) * s t * d w2 t
   return s

heston1  &lt;* updateN heston (return (  k=&gt;1.0;
                                      th=&gt;0.02;
                                      eta=&gt;0.1;
                                      mu=&gt;0.05;
                                      v_0=&gt;0.02;
                                      s_0=&gt;1.0))



fakedata &lt;* sample heston1

pars &lt;* estimateStan heston fakedata

assert_k_pos = Mostly (with pars $ k &gt; 0.0)

assert_v_pos = Mostly (with pars $ v 5.0 &gt; 0.0)

hestonForward &lt;* fastForward heston pars fakedata

future &lt;* sample hestonForward

--future 5.0 *&gt; console

assert_fast_forward = future 0.1 &gt; 0

</pre></td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_k_pos</td><td>pass</td><td>100%</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_v_pos</td><td>pass</td><td>100%</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_fast_forward</td><td>pass</td><td>True</td></tr><tr><td><h4>ODETests</h4></td><td>88 ms</td><td><a onclick="$('#ODETests').toggle();" href="javascript:void(0);">Show/hide code</a></td></tr><tr id="ODETests" style="display: none;"><td colspan="3"><pre>module PreludeTest where

import Prelude.bug

--ODEs

dt = 0.005
tmax = 1.1

mysig_0 = 1.0

D mysig t = sin (mysig t)

assert_ode = between 1.9 2.0 $ mysig 1.0

rvalpha   = 0.1
rvbeta    = 0.01
rvgamma   = 0.05
rvdelta   = 0.001
prey_0      = 50.0 
pred_0      = 15
D prey t    =     prey t    * (rvalpha  - rvbeta   * pred t) 
D pred t    =  -  pred t    * (rvgamma  - rvdelta  * prey t)

assert_prey = between 47 48 $ prey 1.0
assert_pred = between 14.5 15.5 $ pred 1.0

s3 = let zz_0 = 1.0
         D zz = \t -&gt; sin t
     in zz

s4 = let v_0 = -0.07
         w_0 = 0.0
         D v = \t -&gt; 0.01 * v t -  w t
         D w = \t -&gt; 0.3 *  w t - v t
     in v 

assert_let_odes = s4 1.0 &lt; 0 
</pre></td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_ode</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_let_odes</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_prey</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_pred</td><td>pass</td><td>True</td></tr><tr><td><h4>SDETests</h4></td><td>101929 ms</td><td><a onclick="$('#SDETests').toggle();" href="javascript:void(0);">Show/hide code</a></td></tr><tr id="SDETests" style="display: none;"><td colspan="3"><pre>module PreludeTest where

import Distributions.bug

dt = 0.001
tmax = 2.1

w1 = prob
       w ~ wiener
       return (w 1.0)

w2 = prob
       w ~ wiener
       return (w 2.0)

assert_wiener_var1 = SamplerDensity (w1) (normalLogPdf 0 1)
assert_wiener_var2 = SamplerDensity (w2) (normalLogPdf 0 2)

w3 = prob
       w ~ wiener
       s_0 = 1
       d s t = 0 + d w t
       return (s 2.0)

assert_sde_dist = SamplerDensity (w3) (normalLogPdf 1 2)

w4 = prob
       w ~ wiener
       s_0 = 0
       d s t = - s t + d w t
       return (s 2.0)


assert_ou_dist = SamplerDensity (w4) (normalLogPdf 0 0.5) -- ?

</pre></td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_wiener_var1</td><td>pass</td><td>-2.9764799240315134,-2.6595343525536705,-2.586316418264722,-2.1734141953160186,-2.1611926361876646</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_wiener_var2</td><td>pass</td><td>-4.5663867216040535,-4.343939953381995,-4.065651470321179,-4.048491794842881,-3.65610342119753</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_sde_dist</td><td>pass</td><td>-3.2284843354865806,-2.7166201858826566,-2.2827437129830725,-2.2413349144351686,-2.1775820072807237</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_ou_dist</td><td>pass</td><td>-2.124706634139646,-2.043427237516271,-1.851701530362502,-1.8413655658287384,-1.7407053479918304</td></tr><tr><td><h4>LogisticEstim</h4></td><td>418 ms</td><td><a onclick="$('#LogisticEstim').toggle();" href="javascript:void(0);">Show/hide code</a></td></tr><tr id="LogisticEstim" style="display: none;"><td colspan="3"><pre>module RegressCook where

import Distributions.bug

logistic = prob
   offset  ~  normal 0 2
   slope   ~  uniform (-10) 10.0
   repeat 20  $ prob   w ~ uniform 0.0 1.0
                       y ~ bernoulli(invlogit(offset+slope*w))
                       return (w,y) 
  
logistic1 &lt;* updateN logistic $ return ( offset =&gt; (-2.0);
					 slope =&gt; 4.0)

fakeData &lt;* sample logistic1

logitPars &lt;* estimateStan logistic fakeData

assert_mean_pos = Mostly (with logitPars $ slope &gt; 0.5)
            

</pre></td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_mean_pos</td><td>pass</td><td>99.5%</td></tr><tr><td colspan="3"><h4>WishList</h4></td></tr><tr style="background-color: rgb(255, 220, 220);"><td colspan="3"><pre>parse error: parse error in WishList.bug: (line 5, column 0):
unexpected Op &quot;=&quot; at (14,5)
expecting operator</pre></td></tr><tr><td><h4>DensityTests</h4></td><td>260 ms</td><td><a onclick="$('#DensityTests').toggle();" href="javascript:void(0);">Show/hide code</a></td></tr><tr id="DensityTests" style="display: none;"><td colspan="3"><pre>{-
TEST_COMPILER_ONLY
-}

module DensityTests where

import Distributions.bug

assert_normal_sampler_pdf1 = SamplerDensity (normal 0 1) (normalLogPdf 0 1)
--assert_normal_sampler_pdf3 = SamplerDensity (normal 1 10) (normalLogPdf 1 10)
--assert_normal_sampler_pdf5 = SamplerDensity (normal 10 1) (normalLogPdf 10 1)
--assert_unormal_sampler_pdf = SamplerDensity (unormal) (normalLogPdf 0 1)


assert_uniform_sampler_pdf1 = SamplerDensity (uniform 5 10) (uniformLogPdf 5 10)

assert_lognormal_pdf = SamplerDensity (logNormal 1 1) (logNormalLogPdf 1 1)
assert_gamma_pdf1 = SamplerDensity (gamma 1 2.0) (gammaLogPdf 1 2.0)
assert_gamma_pdf2 = SamplerDensity (gamma 9 0.5) (gammaLogPdf 9 0.5)

assert_invgamma_pdf1 = SamplerDensity (invGamma 1 1)   (invGammaLogPdf 1 1)
assert_invgamma_pdf2 = SamplerDensity (invGamma 3 0.5) (invGammaLogPdf 3 0.5)

</pre></td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_normal_sampler_pdf1</td><td>pass</td><td>-2.683241527932337,-2.6238788876207035,-2.279283710560873,-2.195288056955009,-2.167274417234076</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_uniform_sampler_pdf1</td><td>pass</td><td>5.004561415407807,5.007235298398882,5.008649288211018,5.009963749907911,5.0263973930850625</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_lognormal_pdf</td><td>pass</td><td>0.19095975713326985,0.19467633399333623,0.2180711302393088,0.2374947297499688,0.2415460739108462</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_gamma_pdf1</td><td>pass</td><td>0.001169445352880204,0.003595317523108184,0.004574799924398661,0.010144725464445175,0.013525420306686617</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_gamma_pdf2</td><td>pass</td><td>1.1090239019955956,1.1661504760665748,1.2941523652321607,1.2959577967139881,1.6022006256818289</td></tr><tr style="background-color: rgb(255, 220, 220);"><td>assert_invgamma_pdf1</td><td>fail</td><td>p=0; 0.14422121812033242,0.15831890650229963,0.1749750726091127,0.19892108941880193,0.2281453555337413</td></tr><tr style="background-color: rgb(255, 220, 220);"><td>assert_invgamma_pdf2</td><td>fail</td><td>p=0; 0.05452007834323898,0.056163105923353815,0.06108400974463053,0.062158839556179124,0.062359635673501924</td></tr><tr><td><h4>RegressEstim</h4></td><td>528 ms</td><td><a onclick="$('#RegressEstim').toggle();" href="javascript:void(0);">Show/hide code</a></td></tr><tr id="RegressEstim" style="display: none;"><td colspan="3"><pre>module RegressEstim where

import Distributions.bug

samples = 10000

regress = prob
   offset  ~  normal 0 1.0
   sigma   ~  gamma 1 1
   slope   ~  normal 0.0 1.0
   repeat 50  $ prob w ~ uniform 0.0 1.0
                     y ~ normal (offset+slope*w) sigma
                     return $ foo=&gt;w;bar=&gt;y

regress1 &lt;* updateS regress $ return $ offset=&gt; (-0.5);slope=&gt;1;sigma=&gt;0.1

fakedata &lt;* sample regress1

pars &lt;* estimateStan regress fakedata

assert_mean_pos = Mostly (with pars $ slope &gt; 0.5)

</pre></td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_mean_pos</td><td>pass</td><td>97.7%</td></tr><tr><td colspan="3"><h4>NestedRegression</h4></td></tr><tr style="background-color: rgb(255, 220, 220);"><td colspan="3"><pre>runtime error: 
/home/tomn/baysig-exec/tests/asserts/NestedRegression.js:175
))))( (appendStrings((((showBugsNm(dt)( tmax))(&quot;N_final0&quot;))((length(final0))))
                                                                    ^
ReferenceError: final0 is not defined
    at w (/home/tomn/baysig-exec/tests/asserts/NestedRegression.js:175:292)
    at w (/home/tomn/baysig-exec/tests/asserts/NestedRegression.js:175:482)
    at w (/home/tomn/baysig-exec/tests/asserts/NestedRegression.js:175:488)
    at /home/tomn/baysig-exec/tests/asserts/NestedRegression.js:175:498
    at Object.&lt;anonymous&gt; (/home/tomn/baysig-exec/tests/asserts/NestedRegression.js:175:1442)
    at Module._compile (module.js:449:26)
    at Object.Module._extensions..js (module.js:467:10)
    at Module.load (module.js:356:32)
    at Function.Module._load (module.js:312:12)
    at Module.runMain (module.js:492:10)
</pre></td></tr><tr><td><h4>RegressEstimImproper</h4></td><td>499 ms</td><td><a onclick="$('#RegressEstimImproper').toggle();" href="javascript:void(0);">Show/hide code</a></td></tr><tr id="RegressEstimImproper" style="display: none;"><td colspan="3"><pre>module RegressEstim where

import Distributions.bug

samples = 10000

regress0 = prob
   repeat 50  $ prob w ~ uniform 0.0 1.0
                     y ~ normal (1*w-0.5) 0.1
                     return $ foo=&gt;w;bar=&gt;y

regress = prob
   beta_0  ~  improper_uniform
   sigma   ~  gamma 1 1 
   beta_y  ~  improper_uniform
   repeat 50  $ prob w ~ uniform 0.0 1.0
                     y ~ normal (beta_0+beta_y*w) sigma
                     return $ foo=&gt;w;bar=&gt;y

fakedata &lt;* sample regress0

pars &lt;* estimateStan regress fakedata

assert_mean_pos = Mostly (with pars $ beta_y &gt; 0.5)

</pre></td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_mean_pos</td><td>pass</td><td>98.4%</td></tr><tr><td><h4>NotDefined</h4></td><td>0 ms</td><td><a onclick="$('#NotDefined').toggle();" href="javascript:void(0);">Show/hide code</a></td></tr><tr id="NotDefined" style="display: none;"><td colspan="3"><pre>module NotFound where

import Prelude.bug

x = notDefinedAnyWhere + 1
</pre></td></tr><tr style="background-color: rgb(220, 255, 220);"><td>NotDefined_must_fail</td><td>pass</td><td>Undefined variable: notDefinedAnyWhere</td></tr><tr><td><h4>HestonEstim1</h4></td><td>6077 ms</td><td><a onclick="$('#HestonEstim1').toggle();" href="javascript:void(0);">Show/hide code</a></td></tr><tr id="HestonEstim1" style="display: none;"><td colspan="3"><pre>module HestonCook where

import Distributions.bug
tmax = 10.0
dt = 0.01

samples= 2000

heston = prob
   k        ~ gamma 1 1
   th       ~ gamma 1 0.1
   eta      ~ gamma 1 0.1
   mu       ~ normal 0 0.1
   w1       ~  wiener
   w2       ~  wiener
   v_0      ~  gamma 1 0.1
   s_0      ~  uniform 0.0 2.0
   d v t = k * (th - v t) + eta * sqrt (v t) * d w1 t
   d s t = mu * s t + sqrt (v t) * s t * d w2 t
   return (v,s)

heston1  &lt;* updateN heston (return (  k=&gt;1.0;
                                      th=&gt;0.02;
                                      eta=&gt;0.1;
                                      mu=&gt;0.05;
                                      v_0=&gt;0.02;
                                      s_0=&gt;1.0))



fakedata &lt;* sample heston1

pars &lt;* estimateStan heston fakedata

--pars *&gt; console

assert_k_pos = Mostly (with pars $ k &gt; 0.0)




</pre></td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_k_pos</td><td>pass</td><td>100%</td></tr><tr><td><h4>LogisticCook</h4></td><td>7553 ms</td><td><a onclick="$('#LogisticCook').toggle();" href="javascript:void(0);">Show/hide code</a></td></tr><tr id="LogisticCook" style="display: none;"><td colspan="3"><pre>module RegressCook where

import Distributions.bug

logistic = prob
   offset  ~  normal 0 2
   slope   ~  uniform (-10) 10.0
   repeat 20  $ prob   w ~ uniform 0.0 1.0
                       y ~ bernoulli(invlogit(offset+slope*w))
                       return (w,y) 
  
logisticQuantiles &lt;* cookEstimateTestStan logistic 25

assert_logistic_offset = cookAssert $ logisticQuantiles#offset
assert_logistic_slope = cookAssert $ logisticQuantiles#slope

</pre></td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_logistic_offset</td><td>pass</td><td>0.07507507507507508,0.12812812812812813,0.17017017017017017,0.17617617617617617,0.2122122122122122</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_logistic_slope</td><td>pass</td><td>0.016016016016016016,0.04704704704704705,0.13913913913913914,0.19019019019019018,0.22022022022022023</td></tr><tr><td><h4>DiffMeansCook</h4></td><td>14573 ms</td><td><a onclick="$('#DiffMeansCook').toggle();" href="javascript:void(0);">Show/hide code</a></td></tr><tr id="DiffMeansCook" style="display: none;"><td colspan="3"><pre>module DiffMeansCook where

import Distributions.bug

samples = 5000

diffmeans = prob
    mean ~ uniform 0.0 1.0
    diff ~ uniform (-0.5) 0.5
    rvar ~ gamma 1 1
    xs ~ repeat 50 $ normal mean rvar
    ys ~ repeat 50 $ normal (mean+diff) rvar
    return (xs, ys)

              
diffmeansQuantiles &lt;* cookEstimateTestStan diffmeans 25

assert_diffmeans_mean = cookAssert $ diffmeansQuantiles#mean
assert_diffmeans_diff = cookAssert $ diffmeansQuantiles#diff
assert_diffmeans_var = cookAssert $ diffmeansQuantiles#rvar

</pre></td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_diffmeans_mean</td><td>pass</td><td>0.016012810248198558,0.016813450760608487,0.01921537229783827,0.020816653322658127,0.029623698959167333</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_diffmeans_diff</td><td>pass</td><td>0.02802241793434748,0.2674139311449159,0.2962369895916733,0.3130504403522818,0.3474779823859087</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_diffmeans_var</td><td>pass</td><td>0.028823058446757407,0.07926341072858287,0.08326661329063251,0.088871096877502,0.14971977582065651</td></tr><tr><td><h4>RegressCook</h4></td><td>5220 ms</td><td><a onclick="$('#RegressCook').toggle();" href="javascript:void(0);">Show/hide code</a></td></tr><tr id="RegressCook" style="display: none;"><td colspan="3"><pre>module RegressCook where

import Distributions.bug

samples = 10000

regress = prob
   offset  ~  normal 0 1.0
   sigma   ~  gamma 1 1
   slope   ~  normal 0.5 1.0
   repeat 20  $ prob w ~ uniform 0.0 1.0
                     y ~ normal (offset+slope*w) sigma
                     return (w,y) 
              
regressQuantiles &lt;* cookEstimateTestStan regress 25

assert_regress_offset = cookAssert $ regressQuantiles#offset
assert_regress_sigma = cookAssert $ regressQuantiles#sigma
assert_regress_slope = cookAssert $ regressQuantiles#slope

</pre></td></tr><tr style="background-color: rgb(255, 220, 220);"><td>assert_regress_offset</td><td>fail</td><td>p=0.01955005425304399; 0.11411411411411411,0.15415415415415415,0.21921921921921922,0.2882882882882883,0.4174174174174174</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_regress_sigma</td><td>pass</td><td>0.02702702702702703,0.07707707707707707,0.08808808808808809,0.14014014014014015,0.1941941941941942</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_regress_slope</td><td>pass</td><td>0.035035035035035036,0.036036036036036036,0.037037037037037035,0.04704704704704705,0.06106106106106106</td></tr><tr><td><h4>Update</h4></td><td>89 ms</td><td><a onclick="$('#Update').toggle();" href="javascript:void(0);">Show/hide code</a></td></tr><tr id="Update" style="display: none;"><td colspan="3"><pre>module Update where

import Distributions.bug

upsampler = prob
   mean ~ uniform 3 4
   return mean

upsampler1 &lt;* updateS upsampler $ return $ mean=&gt; 1

upsample &lt;* sample upsampler1

assert_update = between 0.5 1.5 upsample
</pre></td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_update</td><td>pass</td><td>True</td></tr><tr><td><h4>Constructor</h4></td><td>0 ms</td><td><a onclick="$('#Constructor').toggle();" href="javascript:void(0);">Show/hide code</a></td></tr><tr id="Constructor" style="display: none;"><td colspan="3"><pre>module Constructor where

import Prelude.bug

x = Cons 5 $ Cons &quot;foo&quot; Nil</pre></td></tr><tr style="background-color: rgb(220, 255, 220);"><td>Constructor_must_fail</td><td>pass</td><td>cannot unify: String and Num ?vint_2013 in x</td></tr><tr><td><h4>RegressDVarCook</h4></td><td>5763 ms</td><td><a onclick="$('#RegressDVarCook').toggle();" href="javascript:void(0);">Show/hide code</a></td></tr><tr id="RegressDVarCook" style="display: none;"><td colspan="3"><pre>module RegressDVarCook where

import Distributions.bug

samples = 10000

regress = prob
   offset  ~  uniform 1.0 5.0
   sigma   ~  gamma 1 1
   slope1  ~  uniform (-0.5) 1.0
   slope   =  exp slope1
   repeat 20  $ prob w ~ uniform 0.0 1.0
                     y ~ normal (offset+slope*w) sigma
                     return (w,y) 
              
regressQuantiles &lt;* cookEstimateTestStan regress 25

assert_regressD_offset = cookAssert $ regressQuantiles#offset
assert_regressD_sigma  = cookAssert $ regressQuantiles#sigma
assert_regressD_slope1 = cookAssert $ regressQuantiles#slope1

</pre></td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_regressD_offset</td><td>pass</td><td>0.01001001001001001,0.011011011011011011,0.08708708708708708,0.12012012012012012,0.18618618618618618</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_regressD_sigma</td><td>pass</td><td>0.02702702702702703,0.037037037037037035,0.06506506506506507,0.08308308308308308,0.2002002002002002</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_regressD_slope1</td><td>pass</td><td>0.005005005005005005,0.006006006006006006,0.05005005005005005,0.06306306306306306,0.0920920920920921</td></tr><tr><td><h4>BugsessTest</h4></td><td>100 ms</td><td><a onclick="$('#BugsessTest').toggle();" href="javascript:void(0);">Show/hide code</a></td></tr><tr id="BugsessTest" style="display: none;"><td colspan="3"><pre>module BugsessTest where

import Prelude.bug

--ASSERT_TYPE five Int

five &lt;* fetch &quot;testdb/five&quot;

rec &lt;* fetch &quot;testdb/testrec&quot;

rec1 &lt;* fetch &quot;testdb/morerec&quot;

assert_fetch1 = five == 5

--ASSERT_TYPE rec {age: Int; name: String}
--assert_name = rec#name == &quot;Tom&quot;
assert_age = rec#age == 35
assert_deep_age = rec1#sub2#zoo#age == 35
assert_stored_signal = between 0 2 $ (rec1#sub2#baz) 0.2</pre></td></tr><tr style="background-color: rgb(220, 255, 220);"><td>asserted_type_of_five</td><td>pass</td><td>Int</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>asserted_type_of_rec</td><td>pass</td><td>{age:Int, name:String}</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_fetch1</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_age</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_deep_age</td><td>pass</td><td>True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_stored_signal</td><td>pass</td><td>True</td></tr><tr><td><h4>Add</h4></td><td>0 ms</td><td><a onclick="$('#Add').toggle();" href="javascript:void(0);">Show/hide code</a></td></tr><tr id="Add" style="display: none;"><td colspan="3"><pre>module Add where

import Prelude.bug

{-
    correct method for typechecking this definition:
    1. we assume that `+&#39; is of type Int -&gt; Int -&gt; Int or equivalent
    2. we can think of the expression as ((+ 5) &quot;foo&quot;)
    3. we begin with the whole expression, detect that it&#39;s an application
       and continue with the left sub-expression
    4. we now need to infer the type of (+ 5) which is another application,
       so we continue with the left sub-expression
    5. `+&#39; is a variable which has type Int -&gt; (Int -&gt; Int) in the context
    6. 5 is a literal of type Int which matches the parameter of `+&#39;
    7. (+ 5) is of type Int -&gt; Int
    8. &quot;foo&quot; is a literal of type String which doesn&#39;t match the expected type Int
       and there exists no way of unifying these two types
    9. the expression is therefore incorrectly typed
-}

x = 5 + &quot;foo&quot;</pre></td></tr><tr style="background-color: rgb(220, 255, 220);"><td>Add_must_fail</td><td>pass</td><td>cannot unify: Num ?refresha_2010 and String in x</td></tr><tr><td><h4>DiffMeansEstim1</h4></td><td>666 ms</td><td><a onclick="$('#DiffMeansEstim1').toggle();" href="javascript:void(0);">Show/hide code</a></td></tr><tr id="DiffMeansEstim1" style="display: none;"><td colspan="3"><pre>module DiffMeansEstim where

import Distributions.bug

samples = 5000

myPriorMean = normal 0.0 1.0
myPriorDiff = uniform (-0.5) 0.5

diffmeans pmean pdiff = prob
    mean ~ pmean
    diff ~ pdiff
    rvar ~ gamma 1 1
    xs ~ repeat 50 $ normal mean rvar
    ys ~ repeat 50 $ normal (mean+diff) rvar
    return $ foo =&gt;xs; bar =&gt; ys

diffmeans2 &lt;* updateS (diffmeans myPriorMean myPriorDiff) $ return $ mean=&gt; 0.5;diff=&gt;0.3;rvar=&gt;0.1

diffmeans1 = diffmeans myPriorMean myPriorDiff

diffmeans3 &lt;* updateS diffmeans1 $ return $ mean=&gt; 0.5;diff=&gt;0.3;rvar=&gt;0.1

fakedata &lt;* sample diffmeans2

pars &lt;* estimateStan (diffmeans myPriorMean myPriorDiff) fakedata

assert_mean_pos = Always (with pars $ mean &gt; 0.0)

assert_diff_pos = Mostly (with pars $ diff &gt; 0.1)</pre></td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_mean_pos</td><td>pass</td><td>True,True,True,True,True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_diff_pos</td><td>pass</td><td>99.9%</td></tr><tr><td><h4>RegressEstim3</h4></td><td>4451 ms</td><td><a onclick="$('#RegressEstim3').toggle();" href="javascript:void(0);">Show/hide code</a></td></tr><tr id="RegressEstim3" style="display: none;"><td colspan="3"><pre>module RegressEstim where

import Distributions.bug

samples = 10000

regress = prob
    beta_0 ~ improper_uniform
    beta_age ~ improper_uniform
    beta_male ~ improper_uniform
    beta_salaryhr ~ improper_uniform
    variance ~ gamma 1 1
    repeat 50 $ prob
       age ~ improper_uniform
       male ~ bernoulli 0.5
       salaryhr ~ binomial 50 0.5
       height ~ normal (((beta_0+(age*beta_age))+((boolToReal male)*beta_male))+((unround salaryhr)*beta_salaryhr)) variance
       return $ (height=&gt;height);((age=&gt;age);((male=&gt;male);(salaryhr=&gt;salaryhr)))

regress2 = prob
    beta_0 ~ improper_uniform
    beta_age ~ improper_uniform
    beta_male ~ improper_uniform
    beta_salaryhr ~ improper_uniform
    variance ~ gamma 1 1
    repeat 50 $ prob
       age ~ any
       male ~ any
       salaryhr ~ any
       height ~ normal (((beta_0+(age*beta_age))+((boolToReal male)*beta_male))+((unround salaryhr)*beta_salaryhr)) variance
       return $ (height=&gt;height);((age=&gt;age);((male=&gt;male);(salaryhr=&gt;salaryhr)))

regress1 = prob
    repeat 50 $ prob
       age ~ normal 30 5
       male ~ bernoulli 0.5
       salaryhr ~ binomial 50 0.5
       height ~ normal (((4.0+(age*2.0))+((boolToReal male)*0.0))+((unround salaryhr)*0.5)) 1.0
       return $ (height=&gt;height);(age=&gt;age);(male=&gt;male);(salaryhr=&gt;salaryhr);(name=&gt;&quot;foo&quot;)

fakedata &lt;* sample regress1

pars &lt;* estimateStan regress fakedata

pars2 &lt;* estimateStan regress2 fakedata

assert_slope_posterior = Mostly (with pars $ beta_age &gt; 0.5)
assert_slope_posterior2 = Mostly (with pars2 $ beta_age &gt; 0.5)

</pre></td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_slope_posterior</td><td>pass</td><td>100%</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_slope_posterior2</td><td>pass</td><td>100%</td></tr><tr><td><h4>RegressEstim1</h4></td><td>528 ms</td><td><a onclick="$('#RegressEstim1').toggle();" href="javascript:void(0);">Show/hide code</a></td></tr><tr id="RegressEstim1" style="display: none;"><td colspan="3"><pre>module RegressEstim where

import Distributions.bug

samples = 10000

regress = prob
   offset  ~  normal 0 1.0
   sigma   ~  gamma 1 1
   slope   ~  normal 0.0 1.0
   repeat 50  $ prob w ~ uniform 0.0 1.0
                     y ~ normal (offset+slope*w) sigma
                     return $ w=&gt;w;y=&gt;y

regress1 = 
   repeat 50  $ prob w ~ uniform 0.0 1.0
                     y ~ normal (1*w-0.5) 0.1
                     return $ w=&gt;w;y=&gt;y;foo=&gt;3.1

fakedata &lt;* sample regress1

pars &lt;* estimateStan regress fakedata

assert_mean_pos = Mostly (with pars $ slope &gt; 0.5)

</pre></td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_mean_pos</td><td>pass</td><td>100%</td></tr><tr><td><h4>RegressEstim2</h4></td><td>1258 ms</td><td><a onclick="$('#RegressEstim2').toggle();" href="javascript:void(0);">Show/hide code</a></td></tr><tr id="RegressEstim2" style="display: none;"><td colspan="3"><pre>module RegressEstim where

import Distributions.bug

samples = 10000

regress = prob
   offset  ~  normal 0 1.0
   sigma   ~  gamma 1 1
   slope   ~  normal 0.0 1.0
   repeat 50  $ prob w ~ uniform 0.0 1.0
                     z ~ normal 0 0.05
                     y ~ normal (offset+slope*w+z) sigma
                     return $ w=&gt;w;y=&gt;y;z=&gt;z

regress1 = 
   repeat 50  $ prob w ~ uniform 0.0 1.0
                     y ~ normal (1*w-0.5) 0.1
                     return $ w=&gt;w;y=&gt;y;foo=&gt;3.1

fakedata &lt;* sample regress1

pars &lt;* estimateStan regress fakedata

assert_slope_posterior = Mostly (with pars $ slope &gt; 0.5)

</pre></td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_slope_posterior</td><td>pass</td><td>99.4%</td></tr><tr><td><h4>DiffMeansEstim</h4></td><td>673 ms</td><td><a onclick="$('#DiffMeansEstim').toggle();" href="javascript:void(0);">Show/hide code</a></td></tr><tr id="DiffMeansEstim" style="display: none;"><td colspan="3"><pre>module DiffMeansEstim where

import Distributions.bug

samples = 5000

diffmeans = prob
    mean ~ uniform 0.0 1.0
    diff ~ uniform (-0.5) 0.5
    rvar ~ gamma 1 1
    xs ~ repeat 50 $ normal mean rvar
    ys ~ repeat 50 $ normal (mean+diff) rvar
    return $ foo =&gt;xs; bar =&gt; ys

diffmeans1 &lt;* updateS diffmeans $ return $ mean=&gt; 0.5;diff=&gt;0.3;rvar=&gt;0.1

fakedata &lt;* sample diffmeans1

pars &lt;* estimateStan diffmeans fakedata

assert_mean_pos = Always (with pars $ mean &gt; 0.0)

assert_diff_pos = Mostly (with pars $ diff &gt; 0.1)</pre></td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_mean_pos</td><td>pass</td><td>True,True,True,True,True</td></tr><tr style="background-color: rgb(220, 255, 220);"><td>assert_diff_pos</td><td>pass</td><td>99.5%</td></tr></table></body></html>